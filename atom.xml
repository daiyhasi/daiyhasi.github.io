<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dotaMyLife</title>
  
  <subtitle>关于我和dota的美好年月</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://daiyhasi.top/"/>
  <updated>2020-08-10T19:39:49.309Z</updated>
  <id>http://daiyhasi.top/</id>
  
  <author>
    <name>daiyhasi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>失业日记--失业第31天</title>
    <link href="http://daiyhasi.top/2020/08/11/%E5%A4%B1%E4%B8%9A%E6%97%A5%E8%AE%B0--%E5%A4%B1%E4%B8%9A%E7%AC%AC31%E5%A4%A9/"/>
    <id>http://daiyhasi.top/2020/08/11/失业日记--失业第31天/</id>
    <published>2020-08-10T19:27:05.698Z</published>
    <updated>2020-08-10T19:39:49.309Z</updated>
    
    <content type="html"><![CDATA[<h4 id="失业第31天"><a href="#失业第31天" class="headerlink" title="失业第31天"></a>失业第31天</h4><p>具体不知道第几天了,差不多得有一个月了吧.算是从今天开始写点东西吧.<br>记录下再次失业的我的状态(对的,不能再这样下去了!!)</p><p>现在北京时间<code>2020年8月11日03:28:46</code>,还有几个小时天就要亮了,键盘声哒哒哒,空调风扇声嘟嘟响,耳鸣声若隐若现.不知道我已经是多少次经历这样的状态了.<br>熬夜,似乎已是我的常态,瞌睡来了倒头就睡现在好像也是我的常态,无规律,无节制,无计划,无头绪,现在也是我的常态</p><p>现在必须做点什么了,定个小目标,从现在起,3天内完成 慕课网剩下的ts课程(拖了好久了)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;失业第31天&quot;&gt;&lt;a href=&quot;#失业第31天&quot; class=&quot;headerlink&quot; title=&quot;失业第31天&quot;&gt;&lt;/a&gt;失业第31天&lt;/h4&gt;&lt;p&gt;具体不知道第几天了,差不多得有一个月了吧.算是从今天开始写点东西吧.&lt;br&gt;记录下再次失业的我的状态(对的,
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Something in my life</title>
    <link href="http://daiyhasi.top/2020/08/11/Something%20in%20my%20life/"/>
    <id>http://daiyhasi.top/2020/08/11/Something in my life/</id>
    <published>2020-08-10T18:59:42.535Z</published>
    <updated>2020-08-10T19:21:35.488Z</updated>
    
    <content type="html"><![CDATA[<h4 id="I-was-just-thinking…"><a href="#I-was-just-thinking…" class="headerlink" title="I was just thinking…"></a>I was just thinking…</h4><p>再次失业的第30天,我一直在思考一个问题,我这么多年来一直坚持的到底是什么.<br>总是得有个什么信仰的,对吧?可惜了,我没有.人生至此,二十有七,我最大的信仰也许就只是爱自己.自私,自利,胆小,懦弱,怠惰,懒散能用来形容一个人惰性的所有形容词应该都能在我身上找到,我很好奇,到底是什么原因造成我这个现状的.总结下我无聊的人生,应是无趣,无聊,毫无生气的一生.</p><h3 id="平凡的人类啊"><a href="#平凡的人类啊" class="headerlink" title="平凡的人类啊!!"></a>平凡的人类啊!!</h3><p>能不能搞点有建树的事?<br>就真这样一辈子碌碌无为燃尽此生?</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;I-was-just-thinking…&quot;&gt;&lt;a href=&quot;#I-was-just-thinking…&quot; class=&quot;headerlink&quot; title=&quot;I was just thinking…&quot;&gt;&lt;/a&gt;I was just thinking…&lt;/h4&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>day03</title>
    <link href="http://daiyhasi.top/2020/04/12/day03/"/>
    <id>http://daiyhasi.top/2020/04/12/day03/</id>
    <published>2020-04-11T20:22:29.210Z</published>
    <updated>2020-04-11T20:25:31.403Z</updated>
    
    <content type="html"><![CDATA[<h5 id="也不算新知识吧-好久没怎么写-class-了-东西都忘了-好多东西虽然当时看的时候觉得自己好像记住了-可是很久不用-回头再来看-就感觉好像都学过-然后写东西的时候都不知道错在哪-还理直气壮的较劲-这就很难受了"><a href="#也不算新知识吧-好久没怎么写-class-了-东西都忘了-好多东西虽然当时看的时候觉得自己好像记住了-可是很久不用-回头再来看-就感觉好像都学过-然后写东西的时候都不知道错在哪-还理直气壮的较劲-这就很难受了" class="headerlink" title="也不算新知识吧,好久没怎么写 class 了,东西都忘了,好多东西虽然当时看的时候觉得自己好像记住了,可是很久不用,回头再来看,就感觉好像都学过,然后写东西的时候都不知道错在哪,还理直气壮的较劲.~~这就很难受了"></a>也不算新知识吧,好久没怎么写 class 了,东西都忘了,好多东西虽然当时看的时候觉得自己好像记住了,可是很久不用,回头再来看,就感觉好像都学过,然后写东西的时候都不知道错在哪,还理直气壮的较劲.~~这就很难受了</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  name = <span class="string">'luo'</span></span><br><span class="line">  <span class="keyword">constructor</span>(age)&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=<span class="string">'age'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是 es6 中对类的实例属性的两种写法,<br>TS 中,出现了好多冒号的写法,这种叫类型注解.可今天就懵了,硬是写出了下面的脑瘫写法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="string">'string'</span></span><br><span class="line">  say() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'test'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这么写,我还在一直纠结为啥 new 出来的实例没有 <code>name</code> 属性,属实短路</p><h5 id="记一个面试题"><a href="#记一个面试题" class="headerlink" title="记一个面试题"></a>记一个面试题</h5><p><strong>super</strong> 关键字一般能用来干嘛<br><code>super</code> 是 es6 中跟 class 一起出现的实现继承的一种方式,<code>super</code> 可以出现在子类中,是父类的引用,可以调用父类上的方法.所以,当子类上的方法覆盖掉父类上的方法之后,如果这时候还想调用父类上原先的方法,就可以用 <code>super</code> 来调用了</p><h4 id="TS-中的访问类型-private-public-protected"><a href="#TS-中的访问类型-private-public-protected" class="headerlink" title="TS 中的访问类型 (private, public, protected)"></a>TS 中的访问类型 (private, public, protected)</h4><p><code>private</code> 允许在类的内部使用 (限制最严苛)<br><code>public</code> 允许在类的内部以及外部使用 (公共的无使用限制)<br><code>protected</code> 允许在类的内部以及继承他的子类中使用 (部分限制)</p><h4 id="ts-中的构造器-constructor"><a href="#ts-中的构造器-constructor" class="headerlink" title="ts 中的构造器 constructor"></a>ts 中的构造器 constructor</h4><p>传统按照 es6 风格的写法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Teacher2 &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> teacher = <span class="keyword">new</span> Teacher2(<span class="string">'luo'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(teacher.name)</span><br></pre></td></tr></table></figure><p>TS 中的简化写法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Teacher2 &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125; <span class="comment">//一行搞定</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(teacher.name)</span><br></pre></td></tr></table></figure><p>再次体会下 ts 的类的继承的魅力</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person2 &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Teacher2 <span class="keyword">extends</span> Person2 &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name) <span class="comment">//子类中出现constructor()函数时, **必须** 在子类的构造器中调用super(),这时这里的super()指的是父类中的构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> teacher = <span class="keyword">new</span> Teacher2(<span class="string">'luo'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(teacher)</span><br><span class="line"><span class="built_in">console</span>.log(teacher.age, <span class="string">' '</span> + teacher.name)</span><br></pre></td></tr></table></figure><p>getter 和 setter 的写法<br>回顾一下 js 中的 setter 和 getter 的写法使用 <code>defineProperty</code> 这个 api 完成的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  _year : <span class="number">2004</span></span><br><span class="line">  edition : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">'year'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//再看看这里的this  测试知道是指向book对象的,</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>:function(newValue)&#123;</span><br><span class="line">    <span class="keyword">if</span>(newValue &gt;<span class="number">2004</span>)&#123;</span><br><span class="line">      <span class="keyword">this</span>._year = newValue</span><br><span class="line">      <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(book.year)</span><br></pre></td></tr></table></figure><p>这种 js 代码在 js 环境中是可以正常执行的,但是在 ts 环境中就不行了,因为 <code>book</code> 对象上并未定义一个 year 属性,写出来这样的代码,ts 就直接飘红了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> _name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">get</span> getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name + <span class="string">' jm'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> setName(name: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">22</span>)</span><br><span class="line">    <span class="keyword">this</span>._name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'luo'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.getName)</span><br><span class="line">person.setName = <span class="string">'liu'</span> <span class="comment">//这里看起来好像是一个变量赋值,但其实内部是触发了setter函数,并将等式右边的值传递给setter函数作为参数</span></span><br></pre></td></tr></table></figure><h4 id="静态属性与单例模式"><a href="#静态属性与单例模式" class="headerlink" title="静态属性与单例模式"></a>静态属性与单例模式</h4><p>这节课听的是慕课网上的 Dell 老师的课程,看的我是拍案叫绝!!不得不说,突然明白了??<br><code>static</code>关键字表静态属性,啥意思,就是把你 <code>class</code> 创建的类当做一个对象,然后把 <code>static</code>关键字后的属性挂载到这个对象上.这就是静态属性!!</p><p>然后 dell 老师表演了一番神奇的最简单的单例模式的写法说明</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Demo &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> instance: Demo <span class="comment">//用于存储类内部new出来的唯一实例 这里private去掉也可以实现单例模式,加上的话应该是不想让外部访问的写法</span></span><br><span class="line">  <span class="keyword">static</span> getInstance() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.instance) &#123;</span><br><span class="line">      <span class="keyword">this</span>.instance = <span class="keyword">new</span> Demo() <span class="comment">//给Demo类上用静态属性 instance 做一个标志量,如果不存在这个标志,则说明是第一次实例化,那么久创建这个实例,并且把它挂在到Demo类的静态属性上.如果存在这个标志,那么直接返回这个变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.instance</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125; <span class="comment">//构造函数加 private 保证外部不能使用 new 关键字创建实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> demo1 = Demo.getInstance()</span><br><span class="line"><span class="keyword">const</span> demo2 = Demo.getInstance()</span><br><span class="line"><span class="built_in">console</span>.log(demo1 === demo2)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;也不算新知识吧-好久没怎么写-class-了-东西都忘了-好多东西虽然当时看的时候觉得自己好像记住了-可是很久不用-回头再来看-就感觉好像都学过-然后写东西的时候都不知道错在哪-还理直气壮的较劲-这就很难受了&quot;&gt;&lt;a href=&quot;#也不算新知识吧-好久没怎么写-c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TS-day01</title>
    <link href="http://daiyhasi.top/2020/04/08/TS-day01/"/>
    <id>http://daiyhasi.top/2020/04/08/TS-day01/</id>
    <published>2020-04-07T19:01:58.784Z</published>
    <updated>2020-04-07T17:54:15.262Z</updated>
    
    <content type="html"><![CDATA[<h4 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h4><p>ts 中的类型指的是静态类型,而 JS 中的类型指的是静态类型<br><strong>静态类型数据可以使我们在代码编写过程中就能发现一些潜在的问题</strong></p><h4 id="发现一个之前老是报错的问题-就是-ts-中总是莫名提示变量名已被占用-但实际上我在当前文件下没有用重复的变量名"><a href="#发现一个之前老是报错的问题-就是-ts-中总是莫名提示变量名已被占用-但实际上我在当前文件下没有用重复的变量名" class="headerlink" title="发现一个之前老是报错的问题,就是 ts 中总是莫名提示变量名已被占用,但实际上我在当前文件下没有用重复的变量名,"></a>发现一个之前老是报错的问题,就是 ts 中总是莫名提示变量名已被占用,但实际上我在当前文件下没有用重复的变量名,</h4><p>这是因为,vscode 对 ts 的支持性比较优秀,会自动检测全局中的变量名,(目前猜测是以文件夹单位)</p><h4 id="初始化-ts-项目文件"><a href="#初始化-ts-项目文件" class="headerlink" title="初始化 ts 项目文件"></a>初始化 ts 项目文件</h4><p><code>tsc --init</code><br>两种方式运行 ts 文件.</p><ol><li>vscode 菜单 终端功能中运行任务–&gt;tsc 监视文件<br>或者</li><li>全局安装 ts-node ,然后终端中 ts-node &lt;文件名&gt;</li></ol><h4 id="静态类型的深度理解"><a href="#静态类型的深度理解" class="headerlink" title="静态类型的深度理解"></a>静态类型的深度理解</h4><p>当定义一个 <code>number</code>类型的变量之后,有两层含义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num: number = <span class="number">123</span></span><br></pre></td></tr></table></figure><ol><li><code>num</code>这个变量只能是 <code>number</code>类型</li><li><code>num</code> 这个变量具备 <code>numer</code>类型上所有的属性和方法(继承!)</li></ol><p>同理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">  x:number,</span><br><span class="line">  y:number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> point: Point &#123;</span><br><span class="line">  x: <span class="number">3</span>,</span><br><span class="line">  y: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上定义了一个变量 <code>point</code> 实现了 <code>interface</code> Point 之后, point 上便有了 <code>Point</code>上所有的属性和方法(继承)</p><p>发现了跟前些天看到 TS 中函数声明方式不一样的写法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getTotal: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line">getTotal()</span><br></pre></td></tr></table></figure><p>这是函数表达式的形式定义函数,记住 <code>:</code> 冒号后面跟的是函数类型, <code>=</code>等号后面跟的是函数的具体实现</p><p>若以函数声明的形式定义函数则上面函数的写法如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotal</span>(<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型注解和类型推断"><a href="#类型注解和类型推断" class="headerlink" title="类型注解和类型推断"></a>类型注解和类型推断</h4><p><code>type annotation</code> 类型注解—-我们告诉 TS 变量是什么类型<br><code>type inference</code> 类型推断—-TS 会自动的尝试分析变量是什么类型</p><p>对于函数参数解构的类型注解的写法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotal</span>(<span class="params">&#123; x, y &#125;: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">getTotal22(&#123; x: <span class="number">3</span>, y: <span class="number">4</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User = &#123; name: <span class="built_in">string</span>; age: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr: User[] = [&#123; name: <span class="string">'luo'</span>, age: <span class="number">27</span> &#125;]</span><br></pre></td></tr></table></figure><p>另一种 <code>class</code> 类的写法也是允许的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Teacher &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr4: Teacher[] = [&#123; name: <span class="string">'luo'</span>, age: <span class="number">28</span> &#125;]</span><br></pre></td></tr></table></figure><p>这种写法不需要去实例化 <code>Teacher</code>, TS 也是识别的,</p><h3 id="元组的定义-tuple"><a href="#元组的定义-tuple" class="headerlink" title="元组的定义 tuple"></a>元组的定义 tuple</h3><p>用于约定数组某一项的类型,如下定义一个元组<br><code>type List = [string, string, number]</code><br>则可以像这样使用这个元组,来约束传入的数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> info: List = [<span class="string">'luo'</span>, <span class="string">'male'</span>, <span class="number">18</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> exInfo: List[] = [</span><br><span class="line">  [<span class="string">'luo'</span>, <span class="string">'male'</span>, <span class="number">18</span>],</span><br><span class="line">  [<span class="string">'jia'</span>, <span class="string">'male'</span>, <span class="number">28</span>],</span><br><span class="line">  [<span class="string">'ming'</span>, <span class="string">'female'</span>, <span class="number">38</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;静态类型与动态类型&quot;&gt;&lt;a href=&quot;#静态类型与动态类型&quot; class=&quot;headerlink&quot; title=&quot;静态类型与动态类型&quot;&gt;&lt;/a&gt;静态类型与动态类型&lt;/h4&gt;&lt;p&gt;ts 中的类型指的是静态类型,而 JS 中的类型指的是静态类型&lt;br&gt;&lt;strong
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TS-day02</title>
    <link href="http://daiyhasi.top/2020/04/08/TS-day02/"/>
    <id>http://daiyhasi.top/2020/04/08/TS-day02/</id>
    <published>2020-04-07T19:01:58.677Z</published>
    <updated>2020-04-07T19:00:26.958Z</updated>
    
    <content type="html"><![CDATA[<h4 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h4><p>实现同一数据结构的代码复用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getName = <span class="function">(<span class="params">person: Person</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(person.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setName = <span class="function">(<span class="params">person: Person, name: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  person.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可选字段</strong><br>当接口出现可选字段时, <code>?</code> 就起作用了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span> <span class="comment">//这里表示 age 可选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只读</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span> <span class="comment">//这里表示 age 可选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ts 函数<strong>传参强校验</strong>的问题</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person1 &#123;</span><br><span class="line">  <span class="comment">// readonly name: string</span></span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getName = <span class="function">(<span class="params">person: Person1</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(person.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'luo'</span>,</span><br><span class="line">  gender: <span class="string">'male'</span> <span class="comment">//这里相对于接口要求多了一个字段,</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getName(person) <span class="comment">//但这里以引用形式传参,是没有问题的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getName(&#123;  //这里以这种对象字面量的形式传参,则TS会进行参数的类型强校验,就会报错了</span></span><br><span class="line"><span class="comment">//   name: 'luo',</span></span><br><span class="line"><span class="comment">//   gender: 'male'</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure><p><strong>propName</strong><br>怎么解决这种情况呢,要么可以避免,要么可以改变接口的形式,加一个<code>propName</code>字段,则上面的接口可以改写成下面的形式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person1 &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口上还可以定义<strong>方法</strong>,如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person1 &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">  say(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口之间能实现<strong>继承 <code>extens</code></strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Teacher1 <span class="keyword">extends</span> Person1 &#123;</span><br><span class="line">  teach(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候若类型定义为 <code>Teacher1</code>类的话,则还需要传入 <code>teach()</code>方法</p><p><strong>函数类型</strong>接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SayHi &#123;</span><br><span class="line">  (word: <span class="built_in">string</span>): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> say: SayHi = <span class="function">(<span class="params">word: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`say <span class="subst">$&#123;word&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口的编译</strong><br>TS 代码在编译完成之后,所有的接口相关的代码,类型相关的代码都会被剔除掉,所以接口规范只是在开发过程中规范开发的手段</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;接口-interface&quot;&gt;&lt;a href=&quot;#接口-interface&quot; class=&quot;headerlink&quot; title=&quot;接口 interface&quot;&gt;&lt;/a&gt;接口 interface&lt;/h4&gt;&lt;p&gt;实现同一数据结构的代码复用&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>4.7天气晴</title>
    <link href="http://daiyhasi.top/2020/04/07/4.7%E5%A4%A9%E6%B0%94%E6%99%B4/"/>
    <id>http://daiyhasi.top/2020/04/07/4.7天气晴/</id>
    <published>2020-04-07T13:04:58.820Z</published>
    <updated>2020-04-07T08:57:02.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vuelidate-表单校验"><a href="#vuelidate-表单校验" class="headerlink" title="vuelidate 表单校验"></a>vuelidate 表单校验</h3><p>不得不说,vuelidate 表单校验还是有坑的,官网也没有明确说明,插件注册是只用按官网上给的两步就可以了,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuelidate <span class="keyword">from</span> <span class="string">'vuelidate'</span></span><br><span class="line">Vue.use(Vuelidate)</span><br></pre></td></tr></table></figure><p>但是,此时放在别的插件中,一般就能用到这个插件挂载到 vue 实例上的对象了,可是这个<strong>vuelidate</strong>就不一样了,只完成以上两步,在组件中是无法拿到 vuelidate 的表单校验对象的.<br>还需要你继续引入校验条件<br><code>import { required } from &#39;vuelidate&#39;</code></p><p>这时才能拿到 vuelidate 的校验对象,才能继续完成表单校验剩下的功能</p><p>下面继续 vuelidate 的使用测试<br>vuelidate 表单验证工具,用字段中的<code>$error</code>属性来表明验证是否通过,而 qusar 使用外部验证的时候是可以给表单元件传递 error 和 error-message,由此 qusar 和 vuelidate 配合使用就简单了,</p><ol><li>在表单元件中绑定属性 <code>:error=&quot;$v.name.$error&quot;</code>,同时给上 <code>bottom-slots</code>属性启用插槽</li><li>做好 name 字段的属性验证 <code>validations</code>字段的正确编写<br>基本上,完成这些工作,一个 <code>name</code> 字段的校验就完成了</li></ol><p>现在发现一个问题,就是 qusar 的外部验证方式,无法完成同一字段不同校验规则的反馈效果.就比如一个字段有<code>required,minLength</code>两条校验,但是只能书写一种校验出错的反馈效果.<br><strong>发现解决方案</strong><br>利用 qusar 的表单元件的 <code>:rules</code>字段可以完成上述需求,查看文档,rules 字段的类型要求如下<br><code>Array of Functions/Strings; If String, then it must be a name of one of the embedded validation rules</code>,<br>所以这里会出现一个有点像高阶函数的写法(有点类似 react 了).</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:rules=<span class="string">"[()=&gt;$v.name.required ||'ceshi1',()=&gt;$v.name.minLength || 'ceshi333']"</span></span><br></pre></td></tr></table></figure><p><strong>表单提交</strong><br>经验证的表单的常见操作是在提交之前检查其有效性。可以通过$invalid 在发送任何请求之前检查状态来轻松完成此操作<br>判断<code>this.$v.$invalid</code>的布尔值,然后在进行提交请求操作</p><p><strong>定制验证器</strong></p><ol><li>需要一个验证器来检查字符串中是否包含很酷的子字符串</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mustBeCool = <span class="function">(<span class="params">value</span>) =&gt;</span> value.indexOf(<span class="string">'cool'</span>) &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure><ol start="2"><li>应用验证器</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  validations: &#123;</span><br><span class="line">  myField: &#123;</span><br><span class="line">    required,</span><br><span class="line">    mustBeCool</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>验证器可选</strong><br>输入被认为是可选的时,可以使用 <code>vuelidate</code> 内置的 <code>helpers</code> 函数<br>这个时候可选验证器需要这样编写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; helpers &#125; <span class="keyword">from</span> <span class="string">'vuelidate/lib/validators'</span></span><br><span class="line"><span class="keyword">const</span> mustBeCool = <span class="function">(<span class="params">value</span>) =&gt;</span> !helpers.req(value) || value.indexOf(<span class="string">'cool'</span>) &gt;= <span class="number">0</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">validations: &#123;</span><br><span class="line">  myField: &#123;</span><br><span class="line">    mustBeCool</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>验证器参数</strong><br>如果验证器需要额外参数,则可以创建一个返回实际验证器的高阶函数,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; helpers &#125; <span class="keyword">from</span> <span class="string">'vuelidate/lib/validators'</span></span><br><span class="line"><span class="keyword">const</span> contains = <span class="function">(<span class="params">param</span>) =&gt;</span></span><br><span class="line">  (value) =&gt; !helpers.req(value) || value.indexOf(param) &gt;= <span class="number">0</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">validations: &#123;</span><br><span class="line">  myField: &#123;</span><br><span class="line">    mustBeCool: contains(<span class="string">'cool'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于正则表达式的验证器</strong><br>使用 regex 助手快速定义正则验证规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; helpers &#125; <span class="keyword">from</span> <span class="string">'vuelidate/lib/validators'</span></span><br><span class="line"><span class="keyword">const</span> alpha = helpers.regex(<span class="string">'alpha'</span>, /^[a-zA-Z]*$/)</span><br></pre></td></tr></table></figure><h4 id="继续-qusar-组件的使用测试"><a href="#继续-qusar-组件的使用测试" class="headerlink" title="继续 qusar 组件的使用测试"></a>继续 qusar 组件的使用测试</h4><ol start="5"><li>面包屑</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;q-breadcrumbs&gt;</span><br><span class="line">  &lt;q-breadcrumbs-el label=<span class="string">"Home"</span> /&gt;</span><br><span class="line">  &lt;q-breadcrumbs-el label=<span class="string">"Components"</span> /&gt;</span><br><span class="line">  &lt;q-breadcrumbs-el label=<span class="string">"Breadcrumbs"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/q-breadcrumbs&gt;</span></span><br></pre></td></tr></table></figure><p>额,突然感觉剩下的官网上的东西依次测试也有点无聊,试试不一样的</p><p>查看到表单一项时,注意到这样一句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QForm钩接到QInput、QSelect或QField包裹的组件中</span><br><span class="line">QInput、QSelect或QField包裹的组件必须使用内部验证（而不是外部验证)</span><br></pre></td></tr></table></figure><p>这也就是是说 QForm 组件包裹着的 QIput 等组件无法使用外部校验规则.<br>经测试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:rules=<span class="string">"[()=&gt;$v.color.required || 'ceshiyong']"</span></span><br></pre></td></tr></table></figure><p>这种将校验结果写进 <code>:runles</code>属性后的形式是可以的<br>而</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:error=<span class="string">"false"</span></span><br></pre></td></tr></table></figure><p>这种接受布尔值的属性校验形式,也是可以的,就是说可以写成如下形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:error=<span class="string">"$v.name.required"</span></span><br></pre></td></tr></table></figure><p>当然这种形式只能接受单一反馈效果,所以还是上面的 <code>:rules</code> 的写法更靠谱</p><h3 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h3><p>表单的重置功能,一般来说表单重置应该是一个 api,可以一次性完成所有表单项的清空,但是 <code>qusar</code>的 reset 功能就有点鸡肋了,它的 reset 功能只给了 <code>q-input</code> .<br>可以像这样来重置 <code>q-input</code>框</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$refs.input.resetValidation()</span><br></pre></td></tr></table></figure><p>而且操作方式是拿到 refs 的引用,然后调用当前引用对象的 <code>resetValidation</code> 方法,这就很鸡肋了.<br>所以看到官网上的清空方式都是直接自己监听事件,在 <code>reset</code> 方法中手动依次清除数据</p><p>接着再次看到 <code>q-form</code> 有一个 api <code>reset</code> ,天真了,这么一个框架怎么可能没有 这么一个小小的功能呢.<br>继续测试 <code>reset</code> 功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$refs.qForm.reset()</span><br></pre></td></tr></table></figure><p>多次测试,发现在事件处理函数中调用这个方法并不起作用,目前还未发现问题出在哪</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;vuelidate-表单校验&quot;&gt;&lt;a href=&quot;#vuelidate-表单校验&quot; class=&quot;headerlink&quot; title=&quot;vuelidate 表单校验&quot;&gt;&lt;/a&gt;vuelidate 表单校验&lt;/h3&gt;&lt;p&gt;不得不说,vuelidate 表单校验还是有
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>4月3日天气晴</title>
    <link href="http://daiyhasi.top/2020/04/03/4%E6%9C%883%E6%97%A5%E5%A4%A9%E6%B0%94%E6%99%B4/"/>
    <id>http://daiyhasi.top/2020/04/03/4月3日天气晴/</id>
    <published>2020-04-03T15:05:02.887Z</published>
    <updated>2020-04-03T15:04:13.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><h4 id="1-qusar的使用"><a href="#1-qusar的使用" class="headerlink" title="1.qusar的使用"></a>1.qusar的使用</h4><h4 id="1-1-qusar-cli"><a href="#1-1-qusar-cli" class="headerlink" title="1.1 qusar cli"></a>1.1 qusar cli</h4><p>qusar脚手架集成了vue,vuex,vue-router以及qusar组件库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ yarn global add @quasar/cli</span><br><span class="line"> 或者</span><br><span class="line">$ npm install -g @quasar/cli</span><br><span class="line"></span><br><span class="line">然后</span><br><span class="line">$ quasar create &lt;folder_name&gt;</span><br></pre></td></tr></table></figure><p>以这种方式搭建的项目使用qusar的组件时是在qusar.conf.js中配置的,配置文件导出一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ctx)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出到控制台的例子:</span></span><br><span class="line">  &#123;</span><br><span class="line">    dev: <span class="literal">true</span>,</span><br><span class="line">    prod: <span class="literal">false</span>,</span><br><span class="line">    mode: &#123; <span class="attr">spa</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    modeName: <span class="string">'spa'</span>,</span><br><span class="line">    target: &#123;&#125;,</span><br><span class="line">    targetName: <span class="literal">undefined</span>,</span><br><span class="line">    arch: &#123;&#125;,</span><br><span class="line">    archName: <span class="literal">undefined</span>,</span><br><span class="line">    debug: <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据这些参数上下文将会被创建</span></span><br><span class="line">  <span class="comment">// 当你运行"quasar dev"或"quasar build"时</span></span><br><span class="line">   devServer: &#123;</span><br><span class="line">    port: ctx.mode.spa</span><br><span class="line">      ? <span class="number">8000</span></span><br><span class="line">      : (ctx.mode.pwa ? <span class="number">9000</span> : <span class="number">9090</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在函数的返回值中配置需要使用的组件</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">  framework: &#123;</span><br><span class="line">    <span class="comment">// NOT needed if using auto-import feature:</span></span><br><span class="line">    components: [</span><br><span class="line">      <span class="string">'QBreadcrumbs'</span>,</span><br><span class="line">      <span class="string">'QBreadcrumbsEl'</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-以vue插件的形式在vue-cli中使用"><a href="#1-2-以vue插件的形式在vue-cli中使用" class="headerlink" title="1.2 以vue插件的形式在vue cli中使用"></a>1.2 以vue插件的形式在vue cli中使用</h4><p>要求vue cli 4.0+版本以上,在项目根目录中添加qusar</p><ol><li><code>vue add qusar</code></li><li>src文件夹下,qusar.js文件中引入待使用的插件 比如 <strong>Notify</strong><br><code>import { Quasar,Notify } from &#39;quasar&#39;</code></li><li>注册qusar时,同时在 <strong>plugins</strong> 选项中注册 <strong>Notify</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Quasar, &#123;</span><br><span class="line">  config: &#123;&#125;,</span><br><span class="line">  components: &#123; <span class="comment">/* not needed if importStrategy is not 'manual' */</span> &#125;,</span><br><span class="line">  directives: &#123; <span class="comment">/* not needed if importStrategy is not 'manual' */</span> &#125;,</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    Notify</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><ol start="4"><li>最后在vue单文件组件中先导入再使用<br><code>import { Notify } from &#39;quasar&#39;</code><br><code>Notify.create({message:&#39;nihao&#39;})</code></li></ol><h4 id="测试qusar表单组件的使用-以下都是用vue插件的形式使用"><a href="#测试qusar表单组件的使用-以下都是用vue插件的形式使用" class="headerlink" title="测试qusar表单组件的使用(以下都是用vue插件的形式使用)"></a>测试qusar表单组件的使用(以下都是用vue插件的形式使用)</h4><ol><li><strong>QInput</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Quasar,</span><br><span class="line">  QInput</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'quasar'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Quasar, &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    QInput</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>input框有个比较有意思的属性,掩码,mask.可以在mask属性的帮助下强制/帮助用户输入特定格式。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 以下是掩码令牌：</span><br><span class="line">#数字</span><br><span class="line">S字母，a到z，不区分大小写</span><br><span class="line">N字母数字，不区分大小写</span><br><span class="line">A字母，转换为大写</span><br><span class="line">a字母，转换为小写</span><br><span class="line">X字母数字，字母转换为大写</span><br><span class="line">x字母数字，字母转换为小写</span><br></pre></td></tr></table></figure></li></ol><p>具体如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;q-input</span><br><span class="line">    filled</span><br><span class="line">    v-model=<span class="string">"phone"</span></span><br><span class="line">    label=<span class="string">"Phone"</span></span><br><span class="line">    mask=<span class="string">"(###) ### - ####"</span></span><br><span class="line">  /&gt;</span><br><span class="line">&lt;q-input</span><br><span class="line">    filled</span><br><span class="line">    v-model=<span class="string">"id"</span></span><br><span class="line">    label=<span class="string">"Special ID"</span></span><br><span class="line">    mask=<span class="string">"###/##"</span></span><br><span class="line">    hint=<span class="string">"Mask: ###/##"</span></span><br><span class="line">  /&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>表单校验<br> 可以使用:rules属性来验证QInput组件,自定义验证器将是一个函数，如果验证器成功，它将返回true，否则将返回带有错误消息的String.<br> 如果设置了lazy-rules，则验证在第一次失去焦点之后开始</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;q-input</span><br><span class="line">   ref=<span class="string">"input"</span></span><br><span class="line">   filled</span><br><span class="line">   v-model=<span class="string">"model"</span></span><br><span class="line">   label=<span class="string">"Required Field"</span></span><br><span class="line">   :rules=<span class="string">"[val =&gt; !!val || 'Field is required']"</span></span><br><span class="line">   lazy-rules</span><br><span class="line"> /&gt;</span><br></pre></td></tr></table></figure><p>规则也可以是异步的</p><p>使用外部验证  <strong>Vuelidate</strong></p><p>仅传递<code>error</code>和<code>error-message</code>（启用<code>bottom-slots</code>以显示此错误消息)</p><h4 id="Vuelidate配合qusar的表单验证的测试"><a href="#Vuelidate配合qusar的表单验证的测试" class="headerlink" title="Vuelidate配合qusar的表单验证的测试"></a>Vuelidate配合qusar的表单验证的测试</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuelidate <span class="keyword">from</span> <span class="string">'vuelidate'</span></span><br><span class="line">Vue.use(Vuelidate)</span><br></pre></td></tr></table></figure><p>这里碰到个问题,不知道是什么意思.</p><p>vuelidate插件的注册照理来说这两步就够了,官网上也是这么操作的,可是就这么做之后我始终无法在组件中拿到vuelidate的表单校验的对象<code>this.$v</code>,这样后续的表单校验操作根本无法进行下去.前前后后翻阅了很多资料博客始终无果…</p><p>在晃荡几小时后再次看向这个问题,就想顺着官网上的内容继续往下写试试,<br>然后<code>import { required } from &#39;vuelidate/lib/validators&#39;</code><br>当这一个引入完成,并配置好对应项后,神奇的事情发生了, <code>this.$v</code> 这个时候又能拿到vuelidate对象了!!</p></li></ol><p>  <strong>All native events are being propagated (you don’t need the ‘.native’ modifier)</strong><br>  所有原生事件都进行过冒泡处理了(不需要添加<code>.native</code>修饰符了)</p><h3 id="qusar组件的使用测试"><a href="#qusar组件的使用测试" class="headerlink" title="qusar组件的使用测试"></a>qusar组件的使用测试</h3><ol><li><p>q-avatar  头像<br><code>&lt;q-avatar size=&quot;100px&quot; font-size=&quot;52px&quot; color=&quot;red&quot; text-color=&quot;white&quot;&gt;罗&lt;/q-avatar&gt;</code></p></li><li><p>q-badge  标记<br><code>&lt;q-badge align=&quot;top&quot;&gt;cli v1.0.0&lt;/q-badge&gt;</code></p></li><li><p>q-banner 横幅</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;q-banner <span class="class"><span class="keyword">class</span></span>=<span class="string">"bg-primary text-white"</span>&gt;</span><br><span class="line">    Unfortunately, the credit card did not go through, please <span class="keyword">try</span> again.</span><br><span class="line">    &lt;template v-slot:action&gt;</span><br><span class="line">      &lt;q-btn flat color=<span class="string">"white"</span> label=<span class="string">"Dismiss"</span> /&gt;</span><br><span class="line">      &lt;q-btn flat color=<span class="string">"white"</span> label=<span class="string">"Update Credit Card"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>q-banner&gt;</span><br></pre></td></tr></table></figure><p>q-banner 有三个插槽位,默认内容 1.default 2.avatar 3.action</p></li><li><p>q-bar 栏</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;q-bar dense <span class="class"><span class="keyword">class</span></span>=<span class="string">"bg-teal text-white"</span>&gt;</span><br><span class="line">    &lt;q-icon /&gt;</span><br><span class="line">    &lt;div&gt;mobi-net&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;4G&lt;/</span>div&gt;</span><br><span class="line">    &lt;q-icon /&gt;</span><br><span class="line">    &lt;q-space /&gt;</span><br><span class="line">    &lt;q-icon  /&gt;</span><br><span class="line">    &lt;div&gt;<span class="number">100</span>%<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;q-icon  /&gt;</span><br><span class="line">  &lt;<span class="regexp">/q-bar&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;h4 id=&quot;1-qusar的使用&quot;&gt;&lt;a href=&quot;#1-qusar的使用&quot; class=&quot;headerlink&quot; title=&quot;1.qus
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2.ts中的函数</title>
    <link href="http://daiyhasi.top/2020/03/29/2.ts%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>http://daiyhasi.top/2020/03/29/2.ts中的函数/</id>
    <published>2020-03-28T16:51:36.859Z</published>
    <updated>2020-03-28T16:40:23.178Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ts-中的函数"><a href="#ts-中的函数" class="headerlink" title="ts 中的函数"></a>ts 中的函数</h3><ol><li><p>ts 中的函数声明</p><ol><li>具名函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Named function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x:number, y:number</span>):<span class="title">number</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>匿名函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x:number,y:number</span>):<span class="title">number</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>书写完整函数类型<br>函数类型包含两部分：参数类型和返回值类型。</p></li><li><p>可选参数和默认参数<br>ts 在 es6 基础上增加了默认参数的另外一种写法,可选参数.<br>JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined。 在 TypeScript 里我们可以在参数名旁使用 ?实现可选参数的功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">val1:string, val2?:number</span>):<span class="title">void</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val1 + <span class="string">" "</span> + val2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ts 中给函数传参必须与函数需求的参数个数一致.多传或少传都会报错,除非设置可选参数或默认参数</p></li><li><p>剩余参数<br>基本与 es6 中剩余参数概念一致,使用…运算符完成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">val1: string, ...rest: any[]</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;val1&#125;</span> <span class="subst">$&#123;rest&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">'nihao'</span>, <span class="number">123</span>, <span class="number">222</span>)</span><br></pre></td></tr></table></figure><p>这里 rest 是一个任意类型的数组,该数组会收集 test 函数从第二个参数开始往后的所有参数</p></li><li><p>this 指向问题</p></li><li><p>重载<br>不像 java,c#这种面向对象语言,js 中是没有函数重载的概念的,但是 ts 中实现了函数重载的功能.即同一个函数,传入不同的参数,完成的功能不一样.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">val1: <span class="built_in">string</span>, val2: <span class="built_in">number</span></span>): <span class="title">void</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">val1: <span class="built_in">number</span>, val2: <span class="built_in">string</span></span>): <span class="title">void</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">val1: <span class="built_in">any</span>, val2: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">if</span> (<span class="params"><span class="keyword">typeof</span> val1 === '<span class="built_in">string</span>'</span>) </span>&#123;</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">log</span>(<span class="params">val1 + '这是前者'</span>)</span></span><br><span class="line"><span class="function">  &#125; <span class="title">else</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是后者'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">123</span>, <span class="string">'abc'</span>)</span><br></pre></td></tr></table></figure><p>看起来像是函数重载,实际上编译完成之后还是变成了如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">val1, val2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> val1 === <span class="string">'string'</span>) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(val1 + <span class="string">'这是前者'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'这是后者'</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">123</span>, <span class="string">'abc'</span>);</span><br></pre></td></tr></table></figure><p>所以我说只是形式上完成了 java 中的函数重载,但是这里的重载跟 java 中的重载还是有区别的</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ts-中的函数&quot;&gt;&lt;a href=&quot;#ts-中的函数&quot; class=&quot;headerlink&quot; title=&quot;ts 中的函数&quot;&gt;&lt;/a&gt;ts 中的函数&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ts 中的函数声明&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;具名函数&lt;/li&gt;
&lt;/ol&gt;
&lt;f
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>我的2020</title>
    <link href="http://daiyhasi.top/2020/03/28/%E6%88%91%E7%9A%842020/"/>
    <id>http://daiyhasi.top/2020/03/28/我的2020/</id>
    <published>2020-03-27T16:31:04.963Z</published>
    <updated>2020-03-27T16:30:42.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我的-2020"><a href="#我的-2020" class="headerlink" title="我的 2020"></a>我的 2020</h2><p>给自己个关键字吧.<br><strong>迷惘的年轻人</strong></p><p>年二七,似乎再叫小年轻也已不太合适,这是一种怎样的尴尬,是一种怎样的矛盾?往日是否无憾,未来是否有所期许.好像一切的一切都变的那么模糊,遥不可及,不论是当初的少年,还是未来不知身在何方的自己.</p><p>总觉得自己能做点什么,总觉得自己会与众不同,后来的后来,不禁发出了吕子乔的感叹:”我竟然是个凡人??”当然,有人会说,你这也是一种成长,终于认清了自己</p><p>最近流行的一句比较有意思的词:终究还是一个人扛下了所有.娱乐至上的年代,这句话显得实在是有些滑稽,可是哦,真的是每个人都能娱乐至上吗,真的是每个人都有娱乐至上的资本吗,虽然滑稽,却也还是能隐约看到背后的默默付出与努力.</p><p>并不是每个人都能充实过好每一天的,并不是每个人都能无愧于自己的昨天的.并不是每个都对自己的未来充满期待的,并不是每个人都能早上按点起床,即使休息日也保持自己高涨的学习热情,一直学习的.说实话,我并不喜欢学习,我学习的目的只有一个,只是这个事情是我觉得稍微还有那么点有趣,稍微还能有那么点成就感,比起别的,这个还稍微容易点.你说要问我想干什么,我最想干的可能是踢足球吧.哈哈哈.</p><p><strong>表现出努力的样子</strong></p><p>不知道有人看过《RE:0》这部动漫没,里面不知道是 18 话还是 19 话,有一段对人性的分析是让我特别特别特别特别特别印象深刻的.那一话我一直不愿意去看第二遍,因为每次看我都能从里面看到自己的样子,表现努力,装作认真,让外人看到自己好像很努力,看到自己努力过了,然后得到别人的一句:<code>&quot;他啊,很努力啊,就是运气太不好&quot;</code>的评价.什么都不愿意改变,什么努力都不做出,却还想平白得到结果,想就这么浑浑噩噩的逃避现实,不愿面对真正的自己.说实话,就这一话,我开始去面对自己最不想面对的自己的真实想法,不愿再去欺骗自己,不想再装作努力过的样子.</p><p><strong>未来仍在明天</strong></p><p>说了这么多,其实也还是只是继续振作自己不要再欺骗自己了,未来还在明天.最近喜欢听朴树,他的歌总能听到些平淡生活中的对未来的期待,就特别喜欢这种感觉.</p><p><strong>定个半年目标吧</strong></p><ul><li>进个大厂(字节跳动)</li></ul><p><strong>学习计划</strong></p><ul><li>4 月 typescript</li></ul><ul><li>5 月 开始 vue3.0(说实话有点想在 vue3 之前看下 react 的 hooks)</li></ul><p><strong>负能量的人也在前行</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;我的-2020&quot;&gt;&lt;a href=&quot;#我的-2020&quot; class=&quot;headerlink&quot; title=&quot;我的 2020&quot;&gt;&lt;/a&gt;我的 2020&lt;/h2&gt;&lt;p&gt;给自己个关键字吧.&lt;br&gt;&lt;strong&gt;迷惘的年轻人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;年二七,似乎
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ts中的数据类型</title>
    <link href="http://daiyhasi.top/2020/03/27/ts%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://daiyhasi.top/2020/03/27/ts中的数据类型/</id>
    <published>2020-03-27T15:44:30.570Z</published>
    <updated>2020-03-27T15:39:15.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TS-中的数据类型"><a href="#TS-中的数据类型" class="headerlink" title="TS 中的数据类型"></a>TS 中的数据类型</h1><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p><code>let state:boolean = false //(ts 中变量的声明方式)</code></p><p>声明变量并加上冒号类型,这是 ts 中声明变量的方式</p><p><strong>注意: TS 中变量一旦声明类型,则该变量就无法再次更改为其他类型的数据</strong></p><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p><code>let num:number = 123</code><br><code>let num:number = 0b10</code></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><code>let str:string = &#39;nihao&#39;</code></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>1.<br><code>let arr:number[] = [1,2,3]</code></p><p>2.数组泛型<br><code>let arr:Array&lt;number&gt;=[1,2,3]</code></p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [string, number]</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>] <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">'hello'</span>] <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p><strong>当访问一个越界的元素，会使用联合类型替代</strong></p><h3 id="枚举类型-enum"><a href="#枚举类型-enum" class="headerlink" title="枚举类型 enum"></a>枚举类型 enum</h3><p>enum 类型是对 JavaScript 标准数据类型的一个补充。 像 C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum flag &#123;success=<span class="number">1</span>,err=<span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">let</span> c:flag = flag.success <span class="comment">//c取到枚举数据类型的数值1,</span></span><br></pre></td></tr></table></figure><p>默认情况下，从 0 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1 开始编号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum flag &#123;success=<span class="number">1</span>,err&#125;</span><br><span class="line"><span class="keyword">let</span> c:flag = flag.err <span class="comment">//c取到枚举数据类型的数值0,</span></span><br></pre></td></tr></table></figure><p>或者，全部都采用手动赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum flag &#123;success=<span class="number">1</span>,err=<span class="number">501</span>&#125;</span><br><span class="line"><span class="keyword">let</span> c:flag = flag.err <span class="comment">//c取到枚举数据类型的数值501,</span></span><br></pre></td></tr></table></figure><p>枚举数据类型存在的意义在于提供一个从名字到值的映射关系</p><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>未指定类型的变量可以用 Any 来标记这些变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str: any = <span class="string">'123'</span></span><br><span class="line">str = <span class="number">123</span> <span class="comment">//这个时候可以改变str的数据类型</span></span><br></pre></td></tr></table></figure><h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><p>某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这个写法是表示这个函数的返回值是void</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'测试代码'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Null-和-undefined"><a href="#Null-和-undefined" class="headerlink" title="Null 和 undefined"></a>Null 和 undefined</h3><p>在 JavaScript 中我们知道 <code>typeof null</code>结果是 object,而<code>typeof undefined</code>结果是 undefined.这个 js 自身的问题在 ts 中被更正了.<br>null 和 undefined 分别有自己的类型分别叫做 null 和 undefined.<br>但是和 void 相似，它们的本身的类型用处不是很大：</p><p><strong>ts 官网上文档说明:</strong><br><strong>默认情况下 null 和 undefined 是所有类型的子类型</strong><br>就是说你可以把 null 和 undefined 赋值给 number 类型的变量。<br>也就是说下面的 ts 代码是允许的?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str: string = <span class="string">'abc'</span></span><br><span class="line">str = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str: string = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p><strong>确实是这样</strong></p><p>但是在<strong>严格模式</strong>下不行.严格模式下通过测试,两种写法都报错了<br><code>Type &#39;null&#39; is not assignable to type &#39;number&#39;.</code><br>很明显是类型错误.</p><h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p>never 类型表示的是那些永不存在的值的类型</p><p>例如， never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never 类型，当它们被永不为真的类型保护所约束时。</p><p>never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">"Something failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>object 表示非原始类型，也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型。</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p><p>类型断言有两种形式。 其一是“尖括号”语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: any = <span class="string">"this is a string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: number = (<span class="xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>someValue).length; //个人理解是用来说明someValue的类型的</span></span><br></pre></td></tr></table></figure><p>其二是 as 语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: any = <span class="string">"this is a string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: number = (someValue <span class="keyword">as</span> string).length;</span><br></pre></td></tr></table></figure><p>两种形式是等价的</p><p>但是在 jsx 中只有 as 语法的类型断言是被允许的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TS-中的数据类型&quot;&gt;&lt;a href=&quot;#TS-中的数据类型&quot; class=&quot;headerlink&quot; title=&quot;TS 中的数据类型&quot;&gt;&lt;/a&gt;TS 中的数据类型&lt;/h1&gt;&lt;h3 id=&quot;布尔值&quot;&gt;&lt;a href=&quot;#布尔值&quot; class=&quot;headerlink
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue的性能优化</title>
    <link href="http://daiyhasi.top/2019/12/25/vue%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://daiyhasi.top/2019/12/25/vue的性能优化/</id>
    <published>2019-12-25T07:32:04.427Z</published>
    <updated>2019-12-25T07:31:37.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、v-if-和-v-show-区分使用场景"><a href="#1、v-if-和-v-show-区分使用场景" class="headerlink" title="1、v-if 和 v-show 区分使用场景"></a>1、v-if 和 v-show 区分使用场景</h2><p>v-if 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；<br>也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>v-show  就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。<br>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p><h3 id="2、computed-和-watch-区分使用场景"><a href="#2、computed-和-watch-区分使用场景" class="headerlink" title="2、computed 和 watch 区分使用场景"></a>2、computed 和 watch 区分使用场景</h3><p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，<br>下一次获取 computed 的值时才会重新计算 computed 的值；<br>watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p><p>运用场景：<br>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p><p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用  watch  选项允许我们执行异步操作 ( 访问一个 API )，<br>限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><h3 id="3、v-for-遍历必须为-item-添加-key，且避免同时使用-v-if"><a href="#3、v-for-遍历必须为-item-添加-key，且避免同时使用-v-if" class="headerlink" title="3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-if"></a>3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</h3><p>（1）v-for 遍历必须为 item 添加 key<br>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。<br>当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。</p><p>（2）v-for 遍历避免同时使用 v-if<br>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</p><p>推荐：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">"user in activeUsers"</span> :key=<span class="string">"user.id"</span>&gt;</span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">   &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp"> &lt;/u</span>l&gt;</span><br><span class="line">   computed: &#123;</span><br><span class="line">       activeUsers: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.users.filter(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> user.isActive</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">   &lt;li</span><br><span class="line">       v-<span class="keyword">for</span>=<span class="string">"user in users"</span></span><br><span class="line">       v-<span class="keyword">if</span>=<span class="string">"user.isActive"</span></span><br><span class="line">       :key=<span class="string">"user.id"</span>&gt;</span><br><span class="line">       &#123;&#123; user.name &#125;&#125;</span><br><span class="line">   &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure><h3 id="4、长列表性能优化"><a href="#4、长列表性能优化" class="headerlink" title="4、长列表性能优化"></a>4、长列表性能优化</h3><p>Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，<br>不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，<br>那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    users: &#123;&#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">async</span> created() &#123;</span><br><span class="line">    <span class="keyword">const</span> users = <span class="keyword">await</span> axios.get(<span class="string">'/api/users'</span>)</span><br><span class="line">    <span class="keyword">this</span>.users = <span class="built_in">Object</span>.freeze(users)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、事件的销毁"><a href="#5、事件的销毁" class="headerlink" title="5、事件的销毁"></a>5、事件的销毁</h3><p>Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。<br>如果在 js 内使用 addEventListener 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.click, <span class="literal">false</span>)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">removeEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.click, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、图片资源懒加载"><a href="#6、图片资源懒加载" class="headerlink" title="6、图片资源懒加载"></a>6、图片资源懒加载</h3><p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载，<br>等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。<br>我们在项目中使用 Vue 的 vue-lazyload 插件：<br>（1）安装插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-lazyload --save-dev</span><br></pre></td></tr></table></figure><p>（2）在入口文件 man.js 中引入并使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueLazyload <span class="keyword">from</span> <span class="string">'vue-lazyload'</span></span><br><span class="line"></span><br><span class="line">复制代码然后再 vue 中直接使用</span><br><span class="line">Vue.use(VueLazyload)</span><br></pre></td></tr></table></figure><p>复制代码或者添加自定义选项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line">  preLoad: <span class="number">1.3</span>,</span><br><span class="line">  error: <span class="string">'dist/error.png'</span>,</span><br><span class="line">  loading: <span class="string">'dist/loading.gif'</span>,</span><br><span class="line">  attempt: <span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>（3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-lazy</span>=<span class="string">"/static/img/1.png"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>以上为 vue-lazyload 插件的简单使用，如果要看插件的更多参数选项，可以查看 vue-lazyload 的 github 地址。<br><a href="https://github.com/hilongjw/vue-lazyload" target="_blank" rel="noopener">https://github.com/hilongjw/vue-lazyload</a></p><h3 id="7、路由懒加载"><a href="#7、路由懒加载" class="headerlink" title="7、路由懒加载"></a>7、路由懒加载</h3><p>Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，<br>当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。<br>如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。<br>这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。<br>路由懒加载：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./Foo.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [&#123; <span class="attr">path</span>: <span class="string">'/foo'</span>, <span class="attr">component</span>: Foo &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="8、第三方插件的按需引入"><a href="#8、第三方插件的按需引入" class="headerlink" title="8、第三方插件的按需引入"></a>8、第三方插件的按需引入</h3><p>我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，<br>然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：<br>（1）首先，安装 babel-plugin-component ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-plugin-component -D</span><br></pre></td></tr></table></figure><p>（2）然后，将 .babelrc 修改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"presets"</span>: [[<span class="string">"es2015"</span>, &#123; <span class="string">"modules"</span>: <span class="literal">false</span> &#125;]],</span><br><span class="line"><span class="string">"plugins"</span>: [</span><br><span class="line">[</span><br><span class="line"><span class="string">"component"</span>,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"libraryName"</span>: <span class="string">"element-ui"</span>,</span><br><span class="line"><span class="string">"styleLibraryName"</span>: <span class="string">"theme-chalk"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）在 main.js 中引入部分组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button, Select &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Button)</span><br><span class="line">Vue.use(Select)</span><br></pre></td></tr></table></figure><h3 id="9、优化无限列表性能"><a href="#9、优化无限列表性能" class="headerlink" title="9、优化无限列表性能"></a>9、优化无限列表性能</h3><p>如果你的应用存在非常长或者无限滚动的列表，那么需要采用   窗口化   的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。<br>你可以参考以下开源项目 vue-virtual-scroll-list  和  vue-virtual-scroller 来优化这种无限列表的场景的。<br>vue-virtual-scroll-list：<a href="https://github.com/tangbc/vue-virtual-scroll-list" target="_blank" rel="noopener">https://github.com/tangbc/vue-virtual-scroll-list</a><br>vue-virtual-scroller： <a href="https://github.com/Akryum/vue-virtual-scroller" target="_blank" rel="noopener">https://github.com/Akryum/vue-virtual-scroller</a></p><h3 id="10、小工具"><a href="#10、小工具" class="headerlink" title="10、小工具"></a>10、小工具</h3><p>第一步：下载 nvm 并安装 (推荐使用 nvm-setup.zip)<br><a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows/releases</a></p><p>第二步：使用 nvm 命令切换 node 版本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="comment">// 会提示 nvw 下的相关命令</span></span><br><span class="line">nvm ls <span class="comment">// 查看已安装 node 版本</span></span><br><span class="line">nvm install vXX <span class="comment">// 安装对应 vXX 版本的 node</span></span><br><span class="line">nvm uninstall vXX <span class="comment">// 卸载对应 vXX 版本的 node</span></span><br><span class="line">nvm use xxx <span class="comment">// 选择使用 XXX 版本</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、v-if-和-v-show-区分使用场景&quot;&gt;&lt;a href=&quot;#1、v-if-和-v-show-区分使用场景&quot; class=&quot;headerlink&quot; title=&quot;1、v-if 和 v-show 区分使用场景&quot;&gt;&lt;/a&gt;1、v-if 和 v-show 区分使用
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue组件间传值方式</title>
    <link href="http://daiyhasi.top/2019/12/25/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://daiyhasi.top/2019/12/25/Vue组件间传值方式总结/</id>
    <published>2019-12-25T06:31:05.398Z</published>
    <updated>2019-12-25T06:29:45.267Z</updated>
    
    <content type="html"><![CDATA[<p>组件三要素：<br>prop，插槽，事件</p><p>prop 传递数据是通过绑定在组件标签本身传递的，而插槽是将组件标签包含的内容传递到子组件对象的<slot>元素内。</p><p>其实就是传递数据、获取数据和操作数据</p><p>那么引申一下，就是怎么在子组件操作父组件的数据，怎么在父组件操作子组件的数据</p><h1 id="父组件操作子组件的数据就是给子组件传递数据、修改或访问子组件的数据，方式有哪些？"><a href="#父组件操作子组件的数据就是给子组件传递数据、修改或访问子组件的数据，方式有哪些？" class="headerlink" title="父组件操作子组件的数据就是给子组件传递数据、修改或访问子组件的数据，方式有哪些？"></a>父组件操作子组件的数据就是给子组件传递数据、修改或访问子组件的数据，方式有哪些？</h1><p>传递数据的方式：prop，将自己的数据传递给子组件，子组件通过注册 props:{}接收父组件传递过来的数据<br>修改和访问子组件的数据：<br>方式一：子组件通过$emit(‘eventName’, param1,…,paramN)这种方式将自己的数据传递给父组件，父组件通过监听@eventName事件名访问子组件数据<br>方式二: 通过给子组件注册ref特性，ref是该组件唯一的标识，可以通过this.$refs.refName 访问子组件 data,methods,computed。。。等数据。<br>eg：<br>子组件：<br>…<br>methods:{<br>sayHi:function(){<br>console.log(‘hi, 派大星’)<br>}<br>}</p><p>父组件中：<br>&lt;base-input ref=”usernameInput” @click=”clickme”&gt;</base-input><br>…<br>methods:{<br>clickme:() =&gt; {<br>this.$refs.usernameInput.sayHi()<br>}<br>}</p><p>也可以给子组件的某个元素比如 div 注册 ref 特性直接在父组件件中访问子组件的 div 元素，比如修改颜色…</p><h1 id="子组件操作父组件的数据就是给子组件传递、修改或访问父组件的数据，方式有哪些？"><a href="#子组件操作父组件的数据就是给子组件传递、修改或访问父组件的数据，方式有哪些？" class="headerlink" title="子组件操作父组件的数据就是给子组件传递、修改或访问父组件的数据，方式有哪些？"></a>子组件操作父组件的数据就是给子组件传递、修改或访问父组件的数据，方式有哪些？</h1><p>传递数据的方式：$emit()<br>访问或修改的方式：<br>  方式一：通过props接收的数据访问<br>  方式二：通过$root 对象，访问父组件的数据和方法，$root 对象就是指 vm 实例<br>eg:<br>父组件:<br>…<br>data:{<br>person: ‘Jackson Yee’<br>},<br>methods:{<br>sing(){<br>console.log(‘陷落美好’)<br>}<br>}</p><p>子组件：<br>…<br>methods:{<br>clicksong(){<br>this.$root.sing()<br>  }<br>}<br>  方式三：$parent 对象可以用来从一个子组件访问父组件的实例。<br>子组件：<br>methods:{<br>clicksong(){<br>this.$parent.sing()<br>  }<br>}<br>甚至可以访问爷爷组件的数据。this.$parent.$parent.msg</p><h1 id="非父子组件的通讯？"><a href="#非父子组件的通讯？" class="headerlink" title="非父子组件的通讯？"></a>非父子组件的通讯？</h1><p>方式一：全局创建一个空 vm 实例,通过给该实例监听和触发事件传递参数<br>eg:<br>var vm = new Vue();<br>vm.$emit();<br>vm.$on();<br>方式二：this.$parent.$parent.$parent.msg<br>方式三：【依赖注入】，通过提供一对 provide 和 inject 选项来传递数据，传递的普通数据是不可以响应的，但是如果传入的是一个可监听的对象，那么这个对象的属性还是可以响应式的。<br>provide 选项指定想要提供给后代组件的数据/方法。<br>inject 选项在任何后代组件里，都可以使用 inject 来接收想要添加在后代组件上的来自于祖先组件的数据/方法；<br>可以把依赖注入看作一部分“大范围有效的 prop”，和 props 相比：<br>祖先组件不需要知道哪些后代组件使用它提供的属性<br>后代组件不需要知道被注入的属性来自哪里</p><p>eg：<br>祖先组件中定义了一个 provide 选项，<br>…<br>data: {<br>msg: ‘hello’<br>}<br>provide: function () {<br>return {<br>msgMap: this.msg<br>}<br>}<br>后代组件中<br>…<br>data:{<br>…<br>},<br>inject:[‘msgMap’]</p><h1 id="还可以通过-localStorage、vuex"><a href="#还可以通过-localStorage、vuex" class="headerlink" title="还可以通过 localStorage、vuex"></a>还可以通过 localStorage、vuex</h1><p>插槽内的数据传递<br>父传给子，直接写在组件标签中间：<br><component-son><br>&lt;template #lala&gt;</p><h1>啦啦啦啦啦啦</h1></template></component-son>子接收,<slot>元素接收：<div>  <slot name="lala"></slot></div><p>子传父，需要在<slot>标签上绑定参数,v-bind:params=”值”</p><div>  <slot v-bind:hi="hi" name="lala"></slot></div> 父接收，通过v-slot:slotNAme="obj",  <component-son>    <template v-slot:lala="obj">      <h1></h1>    </template>  </component-son><p>v-slot:slotNAme=”obj”， obj得到的始终都是对象，obj其实是一个函数的返回值，可以这样认为：</p><p>obj = function(only){<br>return {<br>only<br>}<br>}<br>所以可以对 propSlot 进行解构，直接拿到 slot 对象<br><component-son><br><template v-slot:lala="{hi}"></p><h1></h1></template></component-son><h1 id="事件侦听器"><a href="#事件侦听器" class="headerlink" title="事件侦听器"></a>事件侦听器</h1><p>vue 有三种事件侦听器，都是通过$emit触发事件：<br>$on(eventName, eventHandler)：监听当前实例上的自定义事件。事件可以由 vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。<br>$once(eventName, eventHandler)：一次性侦听一个自定义事件，只触发一次。一旦触发之后，监听器就会被移除。<br>$off(eventName, eventHandler) ：停止侦听一个事件，移除自定义事件监听器。<br>如果没有提供参数，则移除所有的事件监听器；<br>如果只提供了事件，则移除该事件所有的监听器；<br>如果同时提供了事件与回调，则只移除这个回调的监听器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组件三要素：&lt;br&gt;prop，插槽，事件&lt;/p&gt;
&lt;p&gt;prop 传递数据是通过绑定在组件标签本身传递的，而插槽是将组件标签包含的内容传递到子组件对象的&lt;slot&gt;元素内。&lt;/p&gt;
&lt;p&gt;其实就是传递数据、获取数据和操作数据&lt;/p&gt;
&lt;p&gt;那么引申一下，就是怎么在子组件操作
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue 源码学习日记</title>
    <link href="http://daiyhasi.top/2019/12/24/%E6%96%B0%E7%AF%87%E7%AB%A0/"/>
    <id>http://daiyhasi.top/2019/12/24/新篇章/</id>
    <published>2019-12-24T08:41:01.619Z</published>
    <updated>2019-12-24T13:31:34.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录下-vue-源码学习过程"><a href="#记录下-vue-源码学习过程" class="headerlink" title="记录下 vue 源码学习过程"></a>记录下 vue 源码学习过程</h2><h3 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h3><ul><li><p><a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">vue.js 源码</a></p></li><li><p><a href="https://nlrx-wjc.github.io/Learn-Vue-Source-Code/" target="_blank" rel="noopener">逐行剖析 Vue.js 源码</a></p></li><li><p>手写 miniVue<a href="https://www.bilibili.com/video/av54530725" target="_blank" rel="noopener">视频链接</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;记录下-vue-源码学习过程&quot;&gt;&lt;a href=&quot;#记录下-vue-源码学习过程&quot; class=&quot;headerlink&quot; title=&quot;记录下 vue 源码学习过程&quot;&gt;&lt;/a&gt;记录下 vue 源码学习过程&lt;/h2&gt;&lt;h3 id=&quot;资料来源&quot;&gt;&lt;a href=&quot;#资
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>项目总结</title>
    <link href="http://daiyhasi.top/2019/10/31/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://daiyhasi.top/2019/10/31/项目总结/</id>
    <published>2019-10-31T14:34:54.487Z</published>
    <updated>2019-10-31T10:17:16.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="乐淘"><a href="#乐淘" class="headerlink" title="乐淘"></a>乐淘</h1><p>历时一个星期,在老师的带领下总算是敲完了这个项目,收货还是很多的,下面顺着老师和自己的笔记,对页面按照页面静态布局完成情况和功能需求完成情况在回顾总结下.</p><h2 id="静态页面"><a href="#静态页面" class="headerlink" title="静态页面"></a>静态页面</h2><h3 id="出现的问题如下"><a href="#出现的问题如下" class="headerlink" title="出现的问题如下"></a>出现的问题如下</h3><ul><li>页面整体布局问题.<ul><li>圣杯布局</li><li>左侧固定右侧自适应布局(fiexd+padding)</li><li>利用 BFC 实现布局的原理(overflow:hidden)</li></ul></li></ul><ul><li>页面问题需要回头复习的自我感觉有如下<ul><li>rem (实现原理,)</li><li>媒体查询</li><li>面试常考的 div 水平垂直居中问题</li><li>flex 布局 流式布局</li></ul></li></ul><h2 id="下面是各页面的功能完成情况回顾"><a href="#下面是各页面的功能完成情况回顾" class="headerlink" title="下面是各页面的功能完成情况回顾"></a>下面是各页面的功能完成情况回顾</h2><h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><ul><li>关于 common 页,主内容区使用的是 mui 提供的区域滚动插件,插件所在盒子 mui 中设置的是绝对定位,所以在使用插件的时候需要给页面中的区域滚动的父盒子设置相对定位,不然就会出现整个页面都在滚动的情况</li><li>首页轮播使用的是 mui 提供的轮播图插件<ul><li>这里的轮播图还是静态写死的,不涉及到轮播插件初始化的问题</li></ul></li><li>内容区是 ajax 请求返回后的数据动态渲染而成<ul><li>这里我需要强调下关于模板数据的渲染问题,一直有点困惑,甚至是迷糊,每次好像数据能渲染出来就没去深究了,回头得好好看看,使用的模板引擎的数据渲染</li></ul></li></ul><h2 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a>分类页</h2><ul><li>分类页是一个左侧固定右侧自适应的布局,左侧条目和右侧品牌展示区都是 ajax 请求动态渲染.</li><li>由于数据是动态渲染,所以切换功能 click 事件绑定需要使用事件委托,给 li 父盒子 ul 绑定事件.每次 click,获取当前 click 的 li 的品牌 id,在发送请求,动态渲染</li></ul><h2 id="搜索历史页"><a href="#搜索历史页" class="headerlink" title="搜索历史页"></a>搜索历史页</h2><ul><li><p>搜索历史页算是整个项目中比较繁琐的一个环节了.涉及到 localStorage 的存取,动态渲染,json 和数组的数据处理,还有最亮眼的页面间的传值(可能这只是个人觉得啊..)</p></li><li><p>功能需求就是正常的历史记录.</p></li><li><p>总的说来有两块内容,历史记录的展示和页面跳转到详情页,当然,此时跳转需要向详情页传递搜索的关键字.下面简述流程</p><ol><li>输入搜索内容,btn 点击页面会跳转到搜索详情页.当然,在开发阶段,是不会让他跳转的,继续流程,完成历史记录的展示功能.</li><li>拿到搜索框的输入值,通过 localStorage 的 setItem() 方法将搜索的内容存储起来.并设置一个 key. 比如 search</li><li>再次输入,此时需要将之前存好的 search 从 localStorage 中取出来,转成数组,在用 unshift()方法,将新输入的值存入数组中,</li><li>最后将新数组,JSON.stringify() 再次转为字符串,最后存入 localStorage 中</li></ol><ul><li>当然这只是 localStorage 存值取值的使用,每次新数组生成后都需要对搜索历史列表做一次重渲染.</li></ul><p>*</p><ul><li>对于有效限制的优化<ol><li>历史记录的长度限制.在新数组生成后判断一下 length,若大于限制值,pop()一次</li><li>去重.新数组生成之前,拿键入的值跟遍历一次数组,当然这种方案是可行的.使用数组的 indexOf()方法,可以更迅速的判断结果</li></ol></li></ul><ul><li>单条删除功能.这里的 li 也是动态生出的,所以也需要使用事件委托来绑定.</li><li>清空功能. 清空功能需要注意的点在于方法的调用,使用 removeItem(“key”),(我自己做的时候是使用 setItem()将历史记录的关键的内容设置为[]空数组.显然,这是不对的,或者说是不完善的)</li></ul></li></ul><ul><li>再说说页面跳转的传值问题,这是我在这个项目中学到的最为亮眼的技术手段.<ul><li>搜索框每次输入搜索关键字,btn 点击跳转到[详情]./searchList.html 页面,这个时候在 btn 的 click 事件的执行函数中将关键字拼接到地址中. 写成这样的形式 “./searchList.html?key=鞋子”, 这样跳转后的 searchList 页面的 url 就会变成”./searchList.html?key=鞋子”这样的形式.然后在详情页面通过 location.search,就可以拿到”?key=鞋子”这个字符串.最后通过字符截取 split()就可以拿到搜索页传递过来的关键字了.这里自己说起来好像很繁琐,但是实际应用是很广的.<ul><li>比如 get 方式传值,就跟这个差不多</li></ul></li></ul><ul><li>当然 这个手段同样可以用在历史记录的跳转功能上.在历史记录列表渲染的时候,将关键字也同样的拼接在 url 后,这样同样也就实现了页面间传值的问题.</li><li>说起来好像也没那么费劲,但是我的自我感觉是觉得这个手段太牛逼了….</li></ul></li></ul><h2 id="搜索详情页"><a href="#搜索详情页" class="headerlink" title="搜索详情页"></a>搜索详情页</h2><ul><li>搜索详情页页是一个 ajax 动态渲染页面,剩余的排序功能没做了,sort()方式传一个排序函数进去,好像实现起来也不是那么复杂.当然,这里的排序肯定是需要重渲染的,也就是说,是一个异步操作,每次 click 之后,请求数据,按照要求完成排序,然后再将排好的数据重渲染.这样一个过程才是对的.</li><li>这里有一个加载动画,是 css3 完成的.动画的播放是写在 beforeSend 中,在请求完成前,页面内容为动画 div,请求完成后是数据的渲染</li></ul><h2 id="产品详情页"><a href="#产品详情页" class="headerlink" title="产品详情页"></a>产品详情页</h2><ul><li>产品详情页整个是一个大模板渲染而成的,难点在于一个模板原始语法的使用,&lt;% jscode %&gt;.在这样一个标签中可以直接写 js 代码.实现带有逻辑判断的复杂模板</li><li>这里的轮播图和数字输入框插件都是动态渲染而成,在页面加载完成后需要自己手动初始化.<ul><li>这里我踩了一个将近一小时的坑.页面开始渲染,想试试模板的效果,于是在 ajax 请求外,直接调用模板,并初始化轮播图,是数字输入框插件.诶…这时效果是 ok 的.这时肯定的,因为这还没涉及到异步的问题,页面是直接渲染的.当请求发出后,问题就来了,我并没有在 ajax 的回调函数中初始化(注意这才是重点),我还天真的以为自己已经初始化了.完美,找了一小时的 bug,期间完美的认为自己的 js 没有问题.ok,okok,你是最棒的!!</li></ul></li></ul><h2 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h2><ul><li>额,动态渲染,没啥好说的了,接口也没提供,也没多少兴趣写了..</li></ul><h2 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h2><ul><li>简单的表单校验,以及返回值的处理,当然这里使用的是 mui 提供的友好的好看的切牛逼的最接近原生界面的信息提示框</li></ul><h3 id="拦截跳转"><a href="#拦截跳转" class="headerlink" title="拦截跳转"></a>拦截跳转</h3><ul><li>最后的最后说说购物车和用户中心的拦截跳转问题</li><li>理论上,未登录用户是访问不了用户中心和购物车页面的,所以当点击切换到这两个页面时需要做一下拦截.</li><li>我的做法是这样的.当加载这个页面后,向后台发送一个需要登录才能成功的请求,若返回结果是 error,便将页面跳转的 login.html.</li></ul><h2 id="最后说下收获吧"><a href="#最后说下收获吧" class="headerlink" title="最后说下收获吧"></a>最后说下收获吧</h2><ul><li>还是不少的,最起码这个 markdown 还稍微了解了下格式吧~~</li><li>页面布局,jq(实际上用的是 zepto),ajax,页面间传值,模板引擎,拦截跳转,localStorage,history,数组方法,就这么多把先.当然这部分只是移动端的内容,pc 端回头看看,考虑要不要也总结下,不过想想,pc 端管理系统也是大量的增删改查,面向接口的编程,发现没有后台这个前端没法写啊,好难受.作为工具人的小前端,毫无尊严((<del>!</del>))</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;乐淘&quot;&gt;&lt;a href=&quot;#乐淘&quot; class=&quot;headerlink&quot; title=&quot;乐淘&quot;&gt;&lt;/a&gt;乐淘&lt;/h1&gt;&lt;p&gt;历时一个星期,在老师的带领下总算是敲完了这个项目,收货还是很多的,下面顺着老师和自己的笔记,对页面按照页面静态布局完成情况和功能需求完成情况
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://daiyhasi.top/2019/10/27/hello-world/"/>
    <id>http://daiyhasi.top/2019/10/27/hello-world/</id>
    <published>2019-10-27T14:42:13.757Z</published>
    <updated>2019-10-27T14:42:13.757Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
