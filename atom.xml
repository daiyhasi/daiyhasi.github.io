<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dotaMyLife</title>
  
  <subtitle>关于我和dota的美好年月</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://daiyhasi.top/"/>
  <updated>2020-03-27T16:30:42.652Z</updated>
  <id>http://daiyhasi.top/</id>
  
  <author>
    <name>daiyhasi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的2020</title>
    <link href="http://daiyhasi.top/2020/03/28/%E6%88%91%E7%9A%842020/"/>
    <id>http://daiyhasi.top/2020/03/28/我的2020/</id>
    <published>2020-03-27T16:31:04.963Z</published>
    <updated>2020-03-27T16:30:42.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我的-2020"><a href="#我的-2020" class="headerlink" title="我的 2020"></a>我的 2020</h2><p>给自己个关键字吧.<br><strong>迷惘的年轻人</strong></p><p>年二七,似乎再叫小年轻也已不太合适,这是一种怎样的尴尬,是一种怎样的矛盾?往日是否无憾,未来是否有所期许.好像一切的一切都变的那么模糊,遥不可及,不论是当初的少年,还是未来不知身在何方的自己.</p><p>总觉得自己能做点什么,总觉得自己会与众不同,后来的后来,不禁发出了吕子乔的感叹:”我竟然是个凡人??”当然,有人会说,你这也是一种成长,终于认清了自己</p><p>最近流行的一句比较有意思的词:终究还是一个人扛下了所有.娱乐至上的年代,这句话显得实在是有些滑稽,可是哦,真的是每个人都能娱乐至上吗,真的是每个人都有娱乐至上的资本吗,虽然滑稽,却也还是能隐约看到背后的默默付出与努力.</p><p>并不是每个人都能充实过好每一天的,并不是每个人都能无愧于自己的昨天的.并不是每个都对自己的未来充满期待的,并不是每个人都能早上按点起床,即使休息日也保持自己高涨的学习热情,一直学习的.说实话,我并不喜欢学习,我学习的目的只有一个,只是这个事情是我觉得稍微还有那么点有趣,稍微还能有那么点成就感,比起别的,这个还稍微容易点.你说要问我想干什么,我最想干的可能是踢足球吧.哈哈哈.</p><p><strong>表现出努力的样子</strong></p><p>不知道有人看过《RE:0》这部动漫没,里面不知道是 18 话还是 19 话,有一段对人性的分析是让我特别特别特别特别特别印象深刻的.那一话我一直不愿意去看第二遍,因为每次看我都能从里面看到自己的样子,表现努力,装作认真,让外人看到自己好像很努力,看到自己努力过了,然后得到别人的一句:<code>&quot;他啊,很努力啊,就是运气太不好&quot;</code>的评价.什么都不愿意改变,什么努力都不做出,却还想平白得到结果,想就这么浑浑噩噩的逃避现实,不愿面对真正的自己.说实话,就这一话,我开始去面对自己最不想面对的自己的真实想法,不愿再去欺骗自己,不想再装作努力过的样子.</p><p><strong>未来仍在明天</strong></p><p>说了这么多,其实也还是只是继续振作自己不要再欺骗自己了,未来还在明天.最近喜欢听朴树,他的歌总能听到些平淡生活中的对未来的期待,就特别喜欢这种感觉.</p><p><strong>定个半年目标吧</strong></p><ul><li>进个大厂(字节跳动)</li></ul><p><strong>学习计划</strong></p><ul><li>4 月 typescript</li></ul><ul><li>5 月 开始 vue3.0(说实话有点想在 vue3 之前看下 react 的 hooks)</li></ul><p><strong>负能量的人也在前行</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;我的-2020&quot;&gt;&lt;a href=&quot;#我的-2020&quot; class=&quot;headerlink&quot; title=&quot;我的 2020&quot;&gt;&lt;/a&gt;我的 2020&lt;/h2&gt;&lt;p&gt;给自己个关键字吧.&lt;br&gt;&lt;strong&gt;迷惘的年轻人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;年二七,似乎
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ts中的数据类型</title>
    <link href="http://daiyhasi.top/2020/03/27/ts%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://daiyhasi.top/2020/03/27/ts中的数据类型/</id>
    <published>2020-03-27T15:44:30.570Z</published>
    <updated>2020-03-27T15:39:15.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TS-中的数据类型"><a href="#TS-中的数据类型" class="headerlink" title="TS 中的数据类型"></a>TS 中的数据类型</h1><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p><code>let state:boolean = false //(ts 中变量的声明方式)</code></p><p>声明变量并加上冒号类型,这是 ts 中声明变量的方式</p><p><strong>注意: TS 中变量一旦声明类型,则该变量就无法再次更改为其他类型的数据</strong></p><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p><code>let num:number = 123</code><br><code>let num:number = 0b10</code></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><code>let str:string = &#39;nihao&#39;</code></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>1.<br><code>let arr:number[] = [1,2,3]</code></p><p>2.数组泛型<br><code>let arr:Array&lt;number&gt;=[1,2,3]</code></p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [string, number]</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>] <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">'hello'</span>] <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p><strong>当访问一个越界的元素，会使用联合类型替代</strong></p><h3 id="枚举类型-enum"><a href="#枚举类型-enum" class="headerlink" title="枚举类型 enum"></a>枚举类型 enum</h3><p>enum 类型是对 JavaScript 标准数据类型的一个补充。 像 C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum flag &#123;success=<span class="number">1</span>,err=<span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">let</span> c:flag = flag.success <span class="comment">//c取到枚举数据类型的数值1,</span></span><br></pre></td></tr></table></figure><p>默认情况下，从 0 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1 开始编号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum flag &#123;success=<span class="number">1</span>,err&#125;</span><br><span class="line"><span class="keyword">let</span> c:flag = flag.err <span class="comment">//c取到枚举数据类型的数值0,</span></span><br></pre></td></tr></table></figure><p>或者，全部都采用手动赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum flag &#123;success=<span class="number">1</span>,err=<span class="number">501</span>&#125;</span><br><span class="line"><span class="keyword">let</span> c:flag = flag.err <span class="comment">//c取到枚举数据类型的数值501,</span></span><br></pre></td></tr></table></figure><p>枚举数据类型存在的意义在于提供一个从名字到值的映射关系</p><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>未指定类型的变量可以用 Any 来标记这些变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str: any = <span class="string">'123'</span></span><br><span class="line">str = <span class="number">123</span> <span class="comment">//这个时候可以改变str的数据类型</span></span><br></pre></td></tr></table></figure><h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><p>某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这个写法是表示这个函数的返回值是void</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'测试代码'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Null-和-undefined"><a href="#Null-和-undefined" class="headerlink" title="Null 和 undefined"></a>Null 和 undefined</h3><p>在 JavaScript 中我们知道 <code>typeof null</code>结果是 object,而<code>typeof undefined</code>结果是 undefined.这个 js 自身的问题在 ts 中被更正了.<br>null 和 undefined 分别有自己的类型分别叫做 null 和 undefined.<br>但是和 void 相似，它们的本身的类型用处不是很大：</p><p><strong>ts 官网上文档说明:</strong><br><strong>默认情况下 null 和 undefined 是所有类型的子类型</strong><br>就是说你可以把 null 和 undefined 赋值给 number 类型的变量。<br>也就是说下面的 ts 代码是允许的?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str: string = <span class="string">'abc'</span></span><br><span class="line">str = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str: string = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p><strong>确实是这样</strong></p><p>但是在<strong>严格模式</strong>下不行.严格模式下通过测试,两种写法都报错了<br><code>Type &#39;null&#39; is not assignable to type &#39;number&#39;.</code><br>很明显是类型错误.</p><h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p>never 类型表示的是那些永不存在的值的类型</p><p>例如， never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never 类型，当它们被永不为真的类型保护所约束时。</p><p>never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">"Something failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>object 表示非原始类型，也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型。</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p><p>类型断言有两种形式。 其一是“尖括号”语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: any = <span class="string">"this is a string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: number = (<span class="xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>someValue).length; //个人理解是用来说明someValue的类型的</span></span><br></pre></td></tr></table></figure><p>其二是 as 语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: any = <span class="string">"this is a string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: number = (someValue <span class="keyword">as</span> string).length;</span><br></pre></td></tr></table></figure><p>两种形式是等价的</p><p>但是在 jsx 中只有 as 语法的类型断言是被允许的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TS-中的数据类型&quot;&gt;&lt;a href=&quot;#TS-中的数据类型&quot; class=&quot;headerlink&quot; title=&quot;TS 中的数据类型&quot;&gt;&lt;/a&gt;TS 中的数据类型&lt;/h1&gt;&lt;h3 id=&quot;布尔值&quot;&gt;&lt;a href=&quot;#布尔值&quot; class=&quot;headerlink
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue的性能优化</title>
    <link href="http://daiyhasi.top/2019/12/25/vue%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://daiyhasi.top/2019/12/25/vue的性能优化/</id>
    <published>2019-12-25T07:32:04.427Z</published>
    <updated>2019-12-25T07:31:37.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、v-if-和-v-show-区分使用场景"><a href="#1、v-if-和-v-show-区分使用场景" class="headerlink" title="1、v-if 和 v-show 区分使用场景"></a>1、v-if 和 v-show 区分使用场景</h2><p>v-if 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；<br>也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>v-show  就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。<br>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p><h3 id="2、computed-和-watch-区分使用场景"><a href="#2、computed-和-watch-区分使用场景" class="headerlink" title="2、computed 和 watch 区分使用场景"></a>2、computed 和 watch 区分使用场景</h3><p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，<br>下一次获取 computed 的值时才会重新计算 computed 的值；<br>watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p><p>运用场景：<br>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p><p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用  watch  选项允许我们执行异步操作 ( 访问一个 API )，<br>限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><h3 id="3、v-for-遍历必须为-item-添加-key，且避免同时使用-v-if"><a href="#3、v-for-遍历必须为-item-添加-key，且避免同时使用-v-if" class="headerlink" title="3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-if"></a>3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</h3><p>（1）v-for 遍历必须为 item 添加 key<br>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。<br>当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。</p><p>（2）v-for 遍历避免同时使用 v-if<br>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</p><p>推荐：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">"user in activeUsers"</span> :key=<span class="string">"user.id"</span>&gt;</span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">   &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp"> &lt;/u</span>l&gt;</span><br><span class="line">   computed: &#123;</span><br><span class="line">       activeUsers: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.users.filter(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> user.isActive</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">   &lt;li</span><br><span class="line">       v-<span class="keyword">for</span>=<span class="string">"user in users"</span></span><br><span class="line">       v-<span class="keyword">if</span>=<span class="string">"user.isActive"</span></span><br><span class="line">       :key=<span class="string">"user.id"</span>&gt;</span><br><span class="line">       &#123;&#123; user.name &#125;&#125;</span><br><span class="line">   &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure><h3 id="4、长列表性能优化"><a href="#4、长列表性能优化" class="headerlink" title="4、长列表性能优化"></a>4、长列表性能优化</h3><p>Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，<br>不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，<br>那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    users: &#123;&#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">async</span> created() &#123;</span><br><span class="line">    <span class="keyword">const</span> users = <span class="keyword">await</span> axios.get(<span class="string">'/api/users'</span>)</span><br><span class="line">    <span class="keyword">this</span>.users = <span class="built_in">Object</span>.freeze(users)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、事件的销毁"><a href="#5、事件的销毁" class="headerlink" title="5、事件的销毁"></a>5、事件的销毁</h3><p>Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。<br>如果在 js 内使用 addEventListener 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.click, <span class="literal">false</span>)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">removeEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.click, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、图片资源懒加载"><a href="#6、图片资源懒加载" class="headerlink" title="6、图片资源懒加载"></a>6、图片资源懒加载</h3><p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载，<br>等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。<br>我们在项目中使用 Vue 的 vue-lazyload 插件：<br>（1）安装插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-lazyload --save-dev</span><br></pre></td></tr></table></figure><p>（2）在入口文件 man.js 中引入并使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueLazyload <span class="keyword">from</span> <span class="string">'vue-lazyload'</span></span><br><span class="line"></span><br><span class="line">复制代码然后再 vue 中直接使用</span><br><span class="line">Vue.use(VueLazyload)</span><br></pre></td></tr></table></figure><p>复制代码或者添加自定义选项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line">  preLoad: <span class="number">1.3</span>,</span><br><span class="line">  error: <span class="string">'dist/error.png'</span>,</span><br><span class="line">  loading: <span class="string">'dist/loading.gif'</span>,</span><br><span class="line">  attempt: <span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>（3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-lazy</span>=<span class="string">"/static/img/1.png"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>以上为 vue-lazyload 插件的简单使用，如果要看插件的更多参数选项，可以查看 vue-lazyload 的 github 地址。<br><a href="https://github.com/hilongjw/vue-lazyload" target="_blank" rel="noopener">https://github.com/hilongjw/vue-lazyload</a></p><h3 id="7、路由懒加载"><a href="#7、路由懒加载" class="headerlink" title="7、路由懒加载"></a>7、路由懒加载</h3><p>Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，<br>当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。<br>如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。<br>这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。<br>路由懒加载：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./Foo.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [&#123; <span class="attr">path</span>: <span class="string">'/foo'</span>, <span class="attr">component</span>: Foo &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="8、第三方插件的按需引入"><a href="#8、第三方插件的按需引入" class="headerlink" title="8、第三方插件的按需引入"></a>8、第三方插件的按需引入</h3><p>我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，<br>然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：<br>（1）首先，安装 babel-plugin-component ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-plugin-component -D</span><br></pre></td></tr></table></figure><p>（2）然后，将 .babelrc 修改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"presets"</span>: [[<span class="string">"es2015"</span>, &#123; <span class="string">"modules"</span>: <span class="literal">false</span> &#125;]],</span><br><span class="line"><span class="string">"plugins"</span>: [</span><br><span class="line">[</span><br><span class="line"><span class="string">"component"</span>,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"libraryName"</span>: <span class="string">"element-ui"</span>,</span><br><span class="line"><span class="string">"styleLibraryName"</span>: <span class="string">"theme-chalk"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）在 main.js 中引入部分组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button, Select &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Button)</span><br><span class="line">Vue.use(Select)</span><br></pre></td></tr></table></figure><h3 id="9、优化无限列表性能"><a href="#9、优化无限列表性能" class="headerlink" title="9、优化无限列表性能"></a>9、优化无限列表性能</h3><p>如果你的应用存在非常长或者无限滚动的列表，那么需要采用   窗口化   的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。<br>你可以参考以下开源项目 vue-virtual-scroll-list  和  vue-virtual-scroller 来优化这种无限列表的场景的。<br>vue-virtual-scroll-list：<a href="https://github.com/tangbc/vue-virtual-scroll-list" target="_blank" rel="noopener">https://github.com/tangbc/vue-virtual-scroll-list</a><br>vue-virtual-scroller： <a href="https://github.com/Akryum/vue-virtual-scroller" target="_blank" rel="noopener">https://github.com/Akryum/vue-virtual-scroller</a></p><h3 id="10、小工具"><a href="#10、小工具" class="headerlink" title="10、小工具"></a>10、小工具</h3><p>第一步：下载 nvm 并安装 (推荐使用 nvm-setup.zip)<br><a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows/releases</a></p><p>第二步：使用 nvm 命令切换 node 版本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="comment">// 会提示 nvw 下的相关命令</span></span><br><span class="line">nvm ls <span class="comment">// 查看已安装 node 版本</span></span><br><span class="line">nvm install vXX <span class="comment">// 安装对应 vXX 版本的 node</span></span><br><span class="line">nvm uninstall vXX <span class="comment">// 卸载对应 vXX 版本的 node</span></span><br><span class="line">nvm use xxx <span class="comment">// 选择使用 XXX 版本</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、v-if-和-v-show-区分使用场景&quot;&gt;&lt;a href=&quot;#1、v-if-和-v-show-区分使用场景&quot; class=&quot;headerlink&quot; title=&quot;1、v-if 和 v-show 区分使用场景&quot;&gt;&lt;/a&gt;1、v-if 和 v-show 区分使用
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue组件间传值方式</title>
    <link href="http://daiyhasi.top/2019/12/25/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://daiyhasi.top/2019/12/25/Vue组件间传值方式总结/</id>
    <published>2019-12-25T06:31:05.398Z</published>
    <updated>2019-12-25T06:29:45.267Z</updated>
    
    <content type="html"><![CDATA[<p>组件三要素：<br>prop，插槽，事件</p><p>prop 传递数据是通过绑定在组件标签本身传递的，而插槽是将组件标签包含的内容传递到子组件对象的<slot>元素内。</p><p>其实就是传递数据、获取数据和操作数据</p><p>那么引申一下，就是怎么在子组件操作父组件的数据，怎么在父组件操作子组件的数据</p><h1 id="父组件操作子组件的数据就是给子组件传递数据、修改或访问子组件的数据，方式有哪些？"><a href="#父组件操作子组件的数据就是给子组件传递数据、修改或访问子组件的数据，方式有哪些？" class="headerlink" title="父组件操作子组件的数据就是给子组件传递数据、修改或访问子组件的数据，方式有哪些？"></a>父组件操作子组件的数据就是给子组件传递数据、修改或访问子组件的数据，方式有哪些？</h1><p>传递数据的方式：prop，将自己的数据传递给子组件，子组件通过注册 props:{}接收父组件传递过来的数据<br>修改和访问子组件的数据：<br>方式一：子组件通过$emit(‘eventName’, param1,…,paramN)这种方式将自己的数据传递给父组件，父组件通过监听@eventName事件名访问子组件数据<br>方式二: 通过给子组件注册ref特性，ref是该组件唯一的标识，可以通过this.$refs.refName 访问子组件 data,methods,computed。。。等数据。<br>eg：<br>子组件：<br>…<br>methods:{<br>sayHi:function(){<br>console.log(‘hi, 派大星’)<br>}<br>}</p><p>父组件中：<br>&lt;base-input ref=”usernameInput” @click=”clickme”&gt;</base-input><br>…<br>methods:{<br>clickme:() =&gt; {<br>this.$refs.usernameInput.sayHi()<br>}<br>}</p><p>也可以给子组件的某个元素比如 div 注册 ref 特性直接在父组件件中访问子组件的 div 元素，比如修改颜色…</p><h1 id="子组件操作父组件的数据就是给子组件传递、修改或访问父组件的数据，方式有哪些？"><a href="#子组件操作父组件的数据就是给子组件传递、修改或访问父组件的数据，方式有哪些？" class="headerlink" title="子组件操作父组件的数据就是给子组件传递、修改或访问父组件的数据，方式有哪些？"></a>子组件操作父组件的数据就是给子组件传递、修改或访问父组件的数据，方式有哪些？</h1><p>传递数据的方式：$emit()<br>访问或修改的方式：<br>  方式一：通过props接收的数据访问<br>  方式二：通过$root 对象，访问父组件的数据和方法，$root 对象就是指 vm 实例<br>eg:<br>父组件:<br>…<br>data:{<br>person: ‘Jackson Yee’<br>},<br>methods:{<br>sing(){<br>console.log(‘陷落美好’)<br>}<br>}</p><p>子组件：<br>…<br>methods:{<br>clicksong(){<br>this.$root.sing()<br>  }<br>}<br>  方式三：$parent 对象可以用来从一个子组件访问父组件的实例。<br>子组件：<br>methods:{<br>clicksong(){<br>this.$parent.sing()<br>  }<br>}<br>甚至可以访问爷爷组件的数据。this.$parent.$parent.msg</p><h1 id="非父子组件的通讯？"><a href="#非父子组件的通讯？" class="headerlink" title="非父子组件的通讯？"></a>非父子组件的通讯？</h1><p>方式一：全局创建一个空 vm 实例,通过给该实例监听和触发事件传递参数<br>eg:<br>var vm = new Vue();<br>vm.$emit();<br>vm.$on();<br>方式二：this.$parent.$parent.$parent.msg<br>方式三：【依赖注入】，通过提供一对 provide 和 inject 选项来传递数据，传递的普通数据是不可以响应的，但是如果传入的是一个可监听的对象，那么这个对象的属性还是可以响应式的。<br>provide 选项指定想要提供给后代组件的数据/方法。<br>inject 选项在任何后代组件里，都可以使用 inject 来接收想要添加在后代组件上的来自于祖先组件的数据/方法；<br>可以把依赖注入看作一部分“大范围有效的 prop”，和 props 相比：<br>祖先组件不需要知道哪些后代组件使用它提供的属性<br>后代组件不需要知道被注入的属性来自哪里</p><p>eg：<br>祖先组件中定义了一个 provide 选项，<br>…<br>data: {<br>msg: ‘hello’<br>}<br>provide: function () {<br>return {<br>msgMap: this.msg<br>}<br>}<br>后代组件中<br>…<br>data:{<br>…<br>},<br>inject:[‘msgMap’]</p><h1 id="还可以通过-localStorage、vuex"><a href="#还可以通过-localStorage、vuex" class="headerlink" title="还可以通过 localStorage、vuex"></a>还可以通过 localStorage、vuex</h1><p>插槽内的数据传递<br>父传给子，直接写在组件标签中间：<br><component-son><br>&lt;template #lala&gt;</p><h1>啦啦啦啦啦啦</h1></template></component-son>子接收,<slot>元素接收：<div>  <slot name="lala"></slot></div><p>子传父，需要在<slot>标签上绑定参数,v-bind:params=”值”</p><div>  <slot v-bind:hi="hi" name="lala"></slot></div> 父接收，通过v-slot:slotNAme="obj",  <component-son>    <template v-slot:lala="obj">      <h1></h1>    </template>  </component-son><p>v-slot:slotNAme=”obj”， obj得到的始终都是对象，obj其实是一个函数的返回值，可以这样认为：</p><p>obj = function(only){<br>return {<br>only<br>}<br>}<br>所以可以对 propSlot 进行解构，直接拿到 slot 对象<br><component-son><br><template v-slot:lala="{hi}"></p><h1></h1></template></component-son><h1 id="事件侦听器"><a href="#事件侦听器" class="headerlink" title="事件侦听器"></a>事件侦听器</h1><p>vue 有三种事件侦听器，都是通过$emit触发事件：<br>$on(eventName, eventHandler)：监听当前实例上的自定义事件。事件可以由 vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。<br>$once(eventName, eventHandler)：一次性侦听一个自定义事件，只触发一次。一旦触发之后，监听器就会被移除。<br>$off(eventName, eventHandler) ：停止侦听一个事件，移除自定义事件监听器。<br>如果没有提供参数，则移除所有的事件监听器；<br>如果只提供了事件，则移除该事件所有的监听器；<br>如果同时提供了事件与回调，则只移除这个回调的监听器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组件三要素：&lt;br&gt;prop，插槽，事件&lt;/p&gt;
&lt;p&gt;prop 传递数据是通过绑定在组件标签本身传递的，而插槽是将组件标签包含的内容传递到子组件对象的&lt;slot&gt;元素内。&lt;/p&gt;
&lt;p&gt;其实就是传递数据、获取数据和操作数据&lt;/p&gt;
&lt;p&gt;那么引申一下，就是怎么在子组件操作
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue 源码学习日记</title>
    <link href="http://daiyhasi.top/2019/12/24/%E6%96%B0%E7%AF%87%E7%AB%A0/"/>
    <id>http://daiyhasi.top/2019/12/24/新篇章/</id>
    <published>2019-12-24T08:41:01.619Z</published>
    <updated>2019-12-24T13:31:34.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录下-vue-源码学习过程"><a href="#记录下-vue-源码学习过程" class="headerlink" title="记录下 vue 源码学习过程"></a>记录下 vue 源码学习过程</h2><h3 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h3><ul><li><p><a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">vue.js 源码</a></p></li><li><p><a href="https://nlrx-wjc.github.io/Learn-Vue-Source-Code/" target="_blank" rel="noopener">逐行剖析 Vue.js 源码</a></p></li><li><p>手写 miniVue<a href="https://www.bilibili.com/video/av54530725" target="_blank" rel="noopener">视频链接</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;记录下-vue-源码学习过程&quot;&gt;&lt;a href=&quot;#记录下-vue-源码学习过程&quot; class=&quot;headerlink&quot; title=&quot;记录下 vue 源码学习过程&quot;&gt;&lt;/a&gt;记录下 vue 源码学习过程&lt;/h2&gt;&lt;h3 id=&quot;资料来源&quot;&gt;&lt;a href=&quot;#资
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>项目总结</title>
    <link href="http://daiyhasi.top/2019/10/31/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://daiyhasi.top/2019/10/31/项目总结/</id>
    <published>2019-10-31T14:34:54.487Z</published>
    <updated>2019-10-31T10:17:16.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="乐淘"><a href="#乐淘" class="headerlink" title="乐淘"></a>乐淘</h1><p>历时一个星期,在老师的带领下总算是敲完了这个项目,收货还是很多的,下面顺着老师和自己的笔记,对页面按照页面静态布局完成情况和功能需求完成情况在回顾总结下.</p><h2 id="静态页面"><a href="#静态页面" class="headerlink" title="静态页面"></a>静态页面</h2><h3 id="出现的问题如下"><a href="#出现的问题如下" class="headerlink" title="出现的问题如下"></a>出现的问题如下</h3><ul><li>页面整体布局问题.<ul><li>圣杯布局</li><li>左侧固定右侧自适应布局(fiexd+padding)</li><li>利用 BFC 实现布局的原理(overflow:hidden)</li></ul></li></ul><ul><li>页面问题需要回头复习的自我感觉有如下<ul><li>rem (实现原理,)</li><li>媒体查询</li><li>面试常考的 div 水平垂直居中问题</li><li>flex 布局 流式布局</li></ul></li></ul><h2 id="下面是各页面的功能完成情况回顾"><a href="#下面是各页面的功能完成情况回顾" class="headerlink" title="下面是各页面的功能完成情况回顾"></a>下面是各页面的功能完成情况回顾</h2><h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><ul><li>关于 common 页,主内容区使用的是 mui 提供的区域滚动插件,插件所在盒子 mui 中设置的是绝对定位,所以在使用插件的时候需要给页面中的区域滚动的父盒子设置相对定位,不然就会出现整个页面都在滚动的情况</li><li>首页轮播使用的是 mui 提供的轮播图插件<ul><li>这里的轮播图还是静态写死的,不涉及到轮播插件初始化的问题</li></ul></li><li>内容区是 ajax 请求返回后的数据动态渲染而成<ul><li>这里我需要强调下关于模板数据的渲染问题,一直有点困惑,甚至是迷糊,每次好像数据能渲染出来就没去深究了,回头得好好看看,使用的模板引擎的数据渲染</li></ul></li></ul><h2 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a>分类页</h2><ul><li>分类页是一个左侧固定右侧自适应的布局,左侧条目和右侧品牌展示区都是 ajax 请求动态渲染.</li><li>由于数据是动态渲染,所以切换功能 click 事件绑定需要使用事件委托,给 li 父盒子 ul 绑定事件.每次 click,获取当前 click 的 li 的品牌 id,在发送请求,动态渲染</li></ul><h2 id="搜索历史页"><a href="#搜索历史页" class="headerlink" title="搜索历史页"></a>搜索历史页</h2><ul><li><p>搜索历史页算是整个项目中比较繁琐的一个环节了.涉及到 localStorage 的存取,动态渲染,json 和数组的数据处理,还有最亮眼的页面间的传值(可能这只是个人觉得啊..)</p></li><li><p>功能需求就是正常的历史记录.</p></li><li><p>总的说来有两块内容,历史记录的展示和页面跳转到详情页,当然,此时跳转需要向详情页传递搜索的关键字.下面简述流程</p><ol><li>输入搜索内容,btn 点击页面会跳转到搜索详情页.当然,在开发阶段,是不会让他跳转的,继续流程,完成历史记录的展示功能.</li><li>拿到搜索框的输入值,通过 localStorage 的 setItem() 方法将搜索的内容存储起来.并设置一个 key. 比如 search</li><li>再次输入,此时需要将之前存好的 search 从 localStorage 中取出来,转成数组,在用 unshift()方法,将新输入的值存入数组中,</li><li>最后将新数组,JSON.stringify() 再次转为字符串,最后存入 localStorage 中</li></ol><ul><li>当然这只是 localStorage 存值取值的使用,每次新数组生成后都需要对搜索历史列表做一次重渲染.</li></ul><p>*</p><ul><li>对于有效限制的优化<ol><li>历史记录的长度限制.在新数组生成后判断一下 length,若大于限制值,pop()一次</li><li>去重.新数组生成之前,拿键入的值跟遍历一次数组,当然这种方案是可行的.使用数组的 indexOf()方法,可以更迅速的判断结果</li></ol></li></ul><ul><li>单条删除功能.这里的 li 也是动态生出的,所以也需要使用事件委托来绑定.</li><li>清空功能. 清空功能需要注意的点在于方法的调用,使用 removeItem(“key”),(我自己做的时候是使用 setItem()将历史记录的关键的内容设置为[]空数组.显然,这是不对的,或者说是不完善的)</li></ul></li></ul><ul><li>再说说页面跳转的传值问题,这是我在这个项目中学到的最为亮眼的技术手段.<ul><li>搜索框每次输入搜索关键字,btn 点击跳转到[详情]./searchList.html 页面,这个时候在 btn 的 click 事件的执行函数中将关键字拼接到地址中. 写成这样的形式 “./searchList.html?key=鞋子”, 这样跳转后的 searchList 页面的 url 就会变成”./searchList.html?key=鞋子”这样的形式.然后在详情页面通过 location.search,就可以拿到”?key=鞋子”这个字符串.最后通过字符截取 split()就可以拿到搜索页传递过来的关键字了.这里自己说起来好像很繁琐,但是实际应用是很广的.<ul><li>比如 get 方式传值,就跟这个差不多</li></ul></li></ul><ul><li>当然 这个手段同样可以用在历史记录的跳转功能上.在历史记录列表渲染的时候,将关键字也同样的拼接在 url 后,这样同样也就实现了页面间传值的问题.</li><li>说起来好像也没那么费劲,但是我的自我感觉是觉得这个手段太牛逼了….</li></ul></li></ul><h2 id="搜索详情页"><a href="#搜索详情页" class="headerlink" title="搜索详情页"></a>搜索详情页</h2><ul><li>搜索详情页页是一个 ajax 动态渲染页面,剩余的排序功能没做了,sort()方式传一个排序函数进去,好像实现起来也不是那么复杂.当然,这里的排序肯定是需要重渲染的,也就是说,是一个异步操作,每次 click 之后,请求数据,按照要求完成排序,然后再将排好的数据重渲染.这样一个过程才是对的.</li><li>这里有一个加载动画,是 css3 完成的.动画的播放是写在 beforeSend 中,在请求完成前,页面内容为动画 div,请求完成后是数据的渲染</li></ul><h2 id="产品详情页"><a href="#产品详情页" class="headerlink" title="产品详情页"></a>产品详情页</h2><ul><li>产品详情页整个是一个大模板渲染而成的,难点在于一个模板原始语法的使用,&lt;% jscode %&gt;.在这样一个标签中可以直接写 js 代码.实现带有逻辑判断的复杂模板</li><li>这里的轮播图和数字输入框插件都是动态渲染而成,在页面加载完成后需要自己手动初始化.<ul><li>这里我踩了一个将近一小时的坑.页面开始渲染,想试试模板的效果,于是在 ajax 请求外,直接调用模板,并初始化轮播图,是数字输入框插件.诶…这时效果是 ok 的.这时肯定的,因为这还没涉及到异步的问题,页面是直接渲染的.当请求发出后,问题就来了,我并没有在 ajax 的回调函数中初始化(注意这才是重点),我还天真的以为自己已经初始化了.完美,找了一小时的 bug,期间完美的认为自己的 js 没有问题.ok,okok,你是最棒的!!</li></ul></li></ul><h2 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h2><ul><li>额,动态渲染,没啥好说的了,接口也没提供,也没多少兴趣写了..</li></ul><h2 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h2><ul><li>简单的表单校验,以及返回值的处理,当然这里使用的是 mui 提供的友好的好看的切牛逼的最接近原生界面的信息提示框</li></ul><h3 id="拦截跳转"><a href="#拦截跳转" class="headerlink" title="拦截跳转"></a>拦截跳转</h3><ul><li>最后的最后说说购物车和用户中心的拦截跳转问题</li><li>理论上,未登录用户是访问不了用户中心和购物车页面的,所以当点击切换到这两个页面时需要做一下拦截.</li><li>我的做法是这样的.当加载这个页面后,向后台发送一个需要登录才能成功的请求,若返回结果是 error,便将页面跳转的 login.html.</li></ul><h2 id="最后说下收获吧"><a href="#最后说下收获吧" class="headerlink" title="最后说下收获吧"></a>最后说下收获吧</h2><ul><li>还是不少的,最起码这个 markdown 还稍微了解了下格式吧~~</li><li>页面布局,jq(实际上用的是 zepto),ajax,页面间传值,模板引擎,拦截跳转,localStorage,history,数组方法,就这么多把先.当然这部分只是移动端的内容,pc 端回头看看,考虑要不要也总结下,不过想想,pc 端管理系统也是大量的增删改查,面向接口的编程,发现没有后台这个前端没法写啊,好难受.作为工具人的小前端,毫无尊严((<del>!</del>))</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;乐淘&quot;&gt;&lt;a href=&quot;#乐淘&quot; class=&quot;headerlink&quot; title=&quot;乐淘&quot;&gt;&lt;/a&gt;乐淘&lt;/h1&gt;&lt;p&gt;历时一个星期,在老师的带领下总算是敲完了这个项目,收货还是很多的,下面顺着老师和自己的笔记,对页面按照页面静态布局完成情况和功能需求完成情况
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://daiyhasi.top/2019/10/27/hello-world/"/>
    <id>http://daiyhasi.top/2019/10/27/hello-world/</id>
    <published>2019-10-27T14:42:13.757Z</published>
    <updated>2019-10-27T14:42:13.757Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
